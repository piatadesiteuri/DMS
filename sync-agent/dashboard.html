<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EDMS Sync Agent - Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdn.socket.io/4.7.4/socket.io.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
    <script src="renderer.js"></script>
    <style>
        /* Remove all white backgrounds and ensure dark theme */
        body {
            background: #1e293b;
        }

        /* Sidebar styling */
        .w-64 {
            background: #1e293b;
            border-right: 1px solid #334155;
        }

        .w-64 .p-4 {
            border-bottom: 1px solid #334155;
            background: #1e293b;
        }

        .w-64 h2 {
            color: #e2e8f0;
            font-weight: 600;
        }

        .w-64 nav a {
            color: #94a3b8;
            border-left: 3px solid transparent;
            transition: all 0.3s ease;
            margin: 0.25rem 0;
            border-radius: 0.25rem;
            background: #1e293b;
        }

        .w-64 nav a:hover {
            background: #2d3748;
            color: #e2e8f0;
            border-left-color: #60a5fa;
        }

        .w-64 nav a.bg-gray-100 {
            background: #2d3748;
            color: #e2e8f0;
            border-left-color: #60a5fa;
        }

        /* Document items - remove white background */
        .document-item {
            background: #1e293b !important;
            border: 1px solid #334155;
            border-radius: 0.5rem;
            padding: 1rem;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin: 0.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .document-item:hover {
            background: #2d3748 !important;
            border-color: #60a5fa;
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        /* Folder items - remove white background */
        .folder-item {
            background: #1e293b !important;
            border: 1px solid #334155;
            border-radius: 0.5rem;
            padding: 0.5rem;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            margin: 0.25rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .folder-item:hover {
            background: #2d3748 !important;
            border-color: #60a5fa;
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        /* Synced folders section */
        #synced-folders {
            background: #1e293b;
            border-radius: 0.5rem;
            padding: 0.5rem;
        }

        #synced-folders .flex {
            background: #2d3748;
            border: 1px solid #334155;
            border-radius: 0.375rem;
            margin-bottom: 0.5rem;
            transition: all 0.3s ease;
        }

        #synced-folders .flex:hover {
            border-color: #60a5fa;
            transform: translateX(2px);
        }

        /* User section at bottom of sidebar */
        .absolute.bottom-0 {
            background: #1e293b;
            border-top: 1px solid #334155;
            padding: 1rem;
        }

        .absolute.bottom-0 .text-sm {
            color: #e2e8f0;
        }

        .absolute.bottom-0 .text-xs {
            color: #94a3b8;
        }

        /* Modal styling */
        .modal {
            background: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 0.5rem;
        }

        .modal-header {
            background: #2d3748;
            border-bottom: 1px solid #334155;
            padding: 1rem;
            border-radius: 0.5rem 0.5rem 0 0;
        }

        .modal-title {
            color: #e2e8f0;
            font-weight: 600;
        }

        .close-modal {
            color: #94a3b8;
        }

        .close-modal:hover {
            color: #e2e8f0;
        }

        .document-details {
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 0.375rem;
            padding: 1rem;
        }

        .detail-label {
            color: #94a3b8;
            font-size: 0.75rem;
            margin-bottom: 0.25rem;
        }

        .detail-value {
            color: #e2e8f0;
            font-size: 0.875rem;
        }

        .pdf-container {
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 0.375rem;
            padding: 1rem;
        }

        /* Remove any remaining white backgrounds */
        .bg-white {
            background: #1e293b !important;
        }

        .bg-gray-50 {
            background: #2d3748 !important;
        }

        .bg-gray-100 {
            background: #2d3748 !important;
        }

        /* Text colors */
        .text-gray-800 {
            color: #e2e8f0 !important;
        }

        .text-gray-700 {
            color: #cbd5e1 !important;
        }

        .text-gray-600 {
            color: #94a3b8 !important;
        }

        .text-gray-500 {
            color: #64748b !important;
        }

        /* Existing styles ... */
        .document-icon {
            color: #60a5fa;
            font-size: 1.5rem;
        }

        .document-info {
            flex: 1;
        }

        .document-name {
            color: #e2e8f0;
            font-weight: 500;
            font-size: 0.875rem;
        }

        .document-details {
            color: #94a3b8;
            font-size: 0.75rem;
        }

        .document-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .action-button {
            padding: 0.375rem 0.75rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            transition: all 0.2s ease;
        }

        .view-button {
            background: #3b82f6;
            color: white;
        }

        .view-button:hover {
            background: #2563eb;
        }

        .download-button {
            background: #10b981;
            color: white;
        }

        .download-button:hover {
            background: #059669;
        }

        /* Document modal improvements */
        .modal-content {
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 0.5rem;
        }

        .modal-header {
            background: #2d3748;
            border-bottom: 1px solid #334155;
            padding: 1rem;
            border-radius: 0.5rem 0.5rem 0 0;
        }

        .modal-title {
            color: #e2e8f0;
            font-weight: 600;
        }

        .document-details {
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 0.375rem;
            padding: 1rem;
        }

        .detail-label {
            color: #94a3b8;
            font-size: 0.75rem;
            margin-bottom: 0.25rem;
        }

        .detail-value {
            color: #e2e8f0;
            font-size: 0.875rem;
        }

        .pdf-container {
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 0.375rem;
            padding: 1rem;
        }

        /* User section at bottom of sidebar */
        .absolute.bottom-0 {
            background: #1e293b;
            border-top: 1px solid #334155;
            padding: 1rem;
        }

        .absolute.bottom-0 .text-sm {
            color: #e2e8f0;
        }

        .absolute.bottom-0 .text-xs {
            color: #94a3b8;
        }

        /* Existing styles ... */
        .document-item {
            @apply bg-white rounded-lg shadow p-4 hover:shadow-md transition-shadow mt-4;
            background: linear-gradient(to bottom right, #ffffff, #f8fafc);
            border: 1px solid #e2e8f0;
        }

        .document-icon {
            @apply text-2xl;
            color: #0ea5e9;
        }

        .document-info {
            @apply flex-1;
        }

        .document-name {
            @apply text-lg font-semibold;
            color: #0369a1;
        }

        .document-details {
            @apply text-sm mt-2;
            color: #64748b;
        }

        .document-details span {
            @apply block mb-1;
        }

        .document-actions {
            @apply flex justify-end space-x-2 mt-2;
        }

        .action-button {
            @apply px-3 py-1 rounded text-sm font-medium transition-colors;
        }

        .view-button {
            background: linear-gradient(to right, #0ea5e9, #0284c7);
            color: white;
        }

        .view-button:hover {
            background: linear-gradient(to right, #0284c7, #0369a1);
        }

        .download-button {
            background: linear-gradient(to right, #10b981, #059669);
            color: white;
        }

        .download-button:hover {
            background: linear-gradient(to right, #059669, #047857);
            transform: translateY(-1px);
        }

        .folder-item {
            @apply bg-white rounded-lg shadow p-2 hover:shadow-md transition-shadow cursor-pointer;
            background: linear-gradient(to bottom right, #ffffff, #f8fafc);
            border: 1px solid #e2e8f0;
        }

        .folder-icon {
            @apply text-2xl;
            color: #0ea5e9;
        }

        .folder-info {
            @apply flex-1;
        }

        .folder-name {
            @apply text-lg font-semibold;
            color: #0369a1;
        }

        .folder-details {
            @apply text-sm mt-2;
            color: #64748b;
        }

        .folder-details span {
            @apply block mb-1;
        }

        .documents-container {
            @apply mt-4 ml-8 pl-4;
            border-left: 2px solid #e2e8f0;
        }

        .folder-item, .document-item {
            display: flex;
            align-items: center;
            padding: 12px;
            margin: 8px 0;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .folder-item:hover, .document-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
            border-color: #0ea5e9;
        }

        .folder-icon, .document-icon {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 16px;
        }

        .folder-icon i {
            color: #0ea5e9;
            font-size: 24px;
        }

        .document-icon i {
            color: #0ea5e9;
            font-size: 24px;
        }

        .folder-info, .document-info {
            flex: 1;
        }

        .folder-name, .document-name {
            font-size: 16px;
            font-weight: 600;
            color: #0369a1;
            margin-bottom: 4px;
        }

        .folder-details, .document-details {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            font-size: 14px;
            color: #64748b;
        }

        .document-actions {
            display: flex;
            gap: 8px;
        }

        .action-button {
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .view-button {
            background: linear-gradient(to right, #0ea5e9, #0284c7);
            color: white;
        }

        .view-button:hover {
            background: linear-gradient(to right, #0284c7, #0369a1);
            transform: translateY(-1px);
        }

        .download-button {
            background: linear-gradient(to right, #10b981, #059669);
            color: white;
        }

        .download-button:hover {
            background: linear-gradient(to right, #059669, #047857);
            transform: translateY(-1px);
        }

        .action-button i {
            font-size: 1rem;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .document-card {
            animation: fadeIn 0.3s ease-out;
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            backdrop-filter: blur(4px);
        }

        .modal-content {
            position: relative;
            background: white;
            width: 95%;
            height: 95%;
            margin: 1rem auto;
            padding: 1rem;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            background: linear-gradient(to bottom right, #ffffff, #f8fafc);
            border: 1px solid #e2e8f0;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #e2e8f0;
        }

        .modal-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #0369a1;
        }

        .close-modal {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #64748b;
            cursor: pointer;
            padding: 0.25rem;
            transition: color 0.2s ease;
        }

        .close-modal:hover {
            color: #0ea5e9;
        }

        .modal-body {
            display: flex;
            flex: 1;
            gap: 1rem;
            overflow: hidden;
        }

        .document-details {
            width: 300px;
            padding: 1rem;
            background: #f8fafc;
            border-radius: 8px;
            overflow-y: auto;
            border: 1px solid #e2e8f0;
        }

        .document-detail {
            margin-bottom: 0;
            grid-column: span 2;
        }

        .document-detail.half {
            grid-column: span 1;
        }

        .detail-label {
            font-size: 0.75rem;
            font-weight: 500;
            color: #64748b;
            margin-bottom: 0.125rem;
        }

        .detail-value {
            font-size: 0.75rem;
            color: #0369a1;
            word-break: break-word;
        }

        .pdf-container {
            flex: 1;
            background: #f8fafc;
            border-radius: 8px;
            overflow: auto;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 1rem;
            border: 1px solid #e2e8f0;
        }

        #pdfViewer {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            overflow: auto;
        }

        #pdfCanvas {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
            margin-top: 1rem;
            padding-top: 0.5rem;
            border-top: 1px solid #e2e8f0;
        }

        .action-button {
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .download-button {
            background: linear-gradient(to right, #10b981, #059669);
            color: white;
        }

        .action-button:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        .folder-container {
            min-height: 100px;
            border: 2px dashed #e2e8f0;
            border-radius: 12px;
            padding: 20px;
            margin: 10px 0;
            transition: all 0.3s ease;
            background: linear-gradient(to bottom right, #ffffff, #f8fafc);
        }

        .folder-container.drag-over {
            border-color: #0ea5e9;
            background-color: rgba(14, 165, 233, 0.1);
        }

        .drop-zone {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            text-align: center;
        }

        .drop-zone i {
            font-size: 48px;
            color: #0ea5e9;
            margin-bottom: 10px;
        }

        .drop-zone p {
            color: #64748b;
            margin: 0;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 25px;
            border-radius: 8px;
            color: white;
            z-index: 1000;
            animation: slideIn 0.3s ease-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .notification.success {
            background: linear-gradient(to right, #10b981, #059669);
        }

        .notification.error {
            background: linear-gradient(to right, #ef4444, #dc2626);
        }

        .notification.info {
            background: linear-gradient(to right, #0ea5e9, #0284c7);
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .documents-grid {
            @apply grid gap-6;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            padding: 1rem;
        }

        .document-item {
            @apply bg-white rounded-lg shadow p-4 hover:shadow-md transition-shadow mt-4;
            margin: 0.5rem;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .folder-item {
            @apply bg-white rounded-lg shadow p-2 hover:shadow-md transition-shadow cursor-pointer;
            margin: 0.25rem;
            min-height: 80px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .folder-container {
            min-height: 150px;
            border: 2px dashed #ccc;
            border-radius: 12px;
            padding: 2rem;
            margin: 1.5rem 0;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.8);
        }

        .drop-zone {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            text-align: center;
            min-height: 150px;
        }

        .drop-zone i {
            font-size: 48px;
            color: #666;
            margin-bottom: 1rem;
        }

        .drop-zone p {
            color: #666;
            margin: 0;
            font-size: 1.1rem;
        }

        /* Separate styles for Dropbox items */
        .dropbox-item {
            @apply bg-white rounded-lg shadow p-4 hover:shadow-md transition-shadow;
            margin: 0.5rem;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            border: 1px solid #e2e8f0;
            background: linear-gradient(to bottom right, #ffffff, #f8fafc);
        }

        .dropbox-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            border-color: #0ea5e9;
        }

        .dropbox-icon {
            color: #0ea5e9;
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .dropbox-name {
            font-size: 1rem;
            font-weight: 600;
            color: #0369a1;
            margin-bottom: 0.5rem;
        }

        .dropbox-details {
            font-size: 0.875rem;
            color: #64748b;
        }

        /* Grid container for better organization */
        #combined-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 1.5rem;
            padding: 1.5rem;
        }

        /* Section headers */
        .section-header {
            font-size: 1.25rem;
            font-weight: 600;
            color: #0369a1;
            margin: 1.5rem 0 1rem 0;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #e2e8f0;
        }

        /* Container for different sections */
        .section-container {
            margin: 2rem 0;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 12px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        /* Main content layout with sidebar consideration */
        .main-content {
            @apply p-6;
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5rem;
            margin-left: 0;
            min-height: 100vh;
            background: #1e293b; /* Softer dark blue background */
            transition: all 0.3s ease;
            width: 100%;
        }

        /* Professional breadcrumb styling */
        .breadcrumb-container {
            @apply bg-white rounded-lg shadow-sm p-4 mb-6;
            border: 1px solid #e2e8f0;
        }

        .breadcrumb {
            @apply flex items-center space-x-2;
            font-size: 0.875rem;
        }

        .breadcrumb-item {
            @apply flex items-center px-3 py-1.5 rounded-md;
            color: #64748b;
            transition: all 0.2s ease;
        }

        .breadcrumb-item:hover {
            background: #f1f5f9;
        }

        .breadcrumb-item.active {
            @apply bg-blue-50 text-blue-600 font-medium;
        }

        .breadcrumb-separator {
            @apply text-gray-400;
            animation: fadeIn 0.3s ease-out;
        }

        .breadcrumb-icon {
            @apply text-blue-500 mr-2;
            transition: transform 0.2s ease;
        }

        .breadcrumb-item:hover .breadcrumb-icon {
            transform: scale(1.1);
        }

        /* Enhanced grid layout */
        .content-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 1rem;
            padding: 1rem;
            animation: fadeIn 0.3s ease-out;
            width: 100%;
        }

        /* Improved folder and document items */
        .folder-item, .document-item {
            @apply bg-white rounded-lg;
            height: 120px;
            display: flex;
            flex-direction: column;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid #e2e8f0;
            background: linear-gradient(to bottom right, #ffffff, #f8fafc);
            animation: slideIn 0.3s ease-out;
            position: relative;
            overflow: hidden;
        }

        .folder-item::before, .document-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(to right, #0ea5e9, #0284c7);
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }

        .folder-item:hover::before, .document-item:hover::before {
            transform: scaleX(1);
        }

        .folder-item:hover, .document-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
            border-color: #0ea5e9;
        }

        .item-icon {
            @apply text-3xl mb-3;
            color: #0ea5e9;
            transition: transform 0.3s ease;
        }

        .folder-item:hover .item-icon, .document-item:hover .item-icon {
            transform: scale(1.1);
        }

        /* Enhanced drop zone */
        .drop-zone-container {
            @apply bg-white rounded-xl shadow-sm p-6 mb-6;
            border: 2px dashed #e2e8f0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            background: linear-gradient(to bottom right, #ffffff, #f8fafc);
        }

        .drop-zone-container.drag-over {
            border-color: #0ea5e9;
            background: rgba(14, 165, 233, 0.05);
            transform: scale(1.02);
        }

        .drop-zone {
            @apply flex flex-col items-center justify-center p-8;
            min-height: 120px;
            animation: pulse 2s infinite;
        }

        /* Animations */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-10px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.02);
            }
            100% {
                transform: scale(1);
            }
        }

        /* Existing styles ... */

        /* Location display under sidebar */
        .current-location {
            position: fixed;
            top: 0;
            left: 16rem;
            right: 0;
            background: #0f172a;
            padding: 1rem;
            border-bottom: 1px solid #334155;
            z-index: 10;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .location-path {
            @apply flex items-center gap-2;
            font-size: 0.875rem;
            color: #94a3b8;
        }

        .location-separator {
            color: #475569;
        }

        .location-folder {
            color: #e2e8f0;
            font-weight: 500;
        }

        /* Content section styling */
        .content-section {
            background: rgba(30, 41, 59, 0.5);
            border-radius: 0.5rem;
            padding: 1rem;
            border: 1px solid #334155;
        }

        /* Folder and document items */
        .folder-item, .document-item {
            background: #1e293b;
            border: 1px solid #334155;
            transition: all 0.3s ease;
        }

        .folder-item:hover, .document-item:hover {
            background: #2d3748;
            border-color: #3b82f6;
            transform: translateY(-2px);
        }

        .item-icon {
            color: #60a5fa;
        }

        .folder-name, .document-name {
            color: #e2e8f0;
        }

        .folder-details, .document-details {
            color: #94a3b8;
        }

        /* Drop zone styling */
        .drop-zone-container {
            background: #1e293b;
            border: 2px dashed #475569;
            transition: all 0.3s ease;
            cursor: pointer;
            border-radius: 0.75rem;
            margin: 1rem 0;
        }

        .drop-zone-container:hover {
            background: #2d3748;
            border-color: #60a5fa;
        }

        .drop-zone-container.drag-over {
            background: #2563eb !important;
            border-color: #93c5fd !important;
            transform: scale(1.02);
            box-shadow: 0 8px 16px rgba(96, 165, 250, 0.3);
        }

        .drop-zone {
            padding: 2rem;
            text-align: center;
            transition: all 0.3s ease;
        }

        .drop-zone i {
            color: #60a5fa;
            transition: all 0.3s ease;
        }

        .drop-zone p {
            color: #94a3b8;
            transition: all 0.3s ease;
        }

        .drop-zone-container.drag-over .drop-zone i {
            color: #ffffff !important;
            transform: scale(1.1);
        }

        .drop-zone-container.drag-over .drop-zone p {
            color: #ffffff !important;
            font-weight: 500;
        }

        /* Header styling */
        .header-content {
            background: #1e293b;
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid #334155;
        }

        h1 {
            color: #e2e8f0;
        }

        /* Button styling */
        #selectFolder {
            background: #3b82f6;
            color: #ffffff;
            transition: all 0.3s ease;
        }

        #selectFolder:hover {
            background: #2563eb;
            transform: translateY(-1px);
        }

        /* Modal styling */
        .modal-content {
            background: #1e293b;
            border: 1px solid #334155;
        }

        .modal-header {
            border-bottom: 1px solid #334155;
        }

        .modal-title {
            color: #e2e8f0;
        }

        .close-modal {
            color: #94a3b8;
        }

        .close-modal:hover {
            color: #e2e8f0;
        }

        .document-details {
            background: #0f172a;
            border: 1px solid #334155;
        }

        .detail-label {
            color: #94a3b8;
        }

        .detail-value {
            color: #e2e8f0;
        }

        .pdf-container {
            background: #0f172a;
            border: 1px solid #334155;
        }

        /* Existing styles ... */

        /* Add these new styles for the toast system */
        .toast-container {
            position: fixed;
            top: 80px; /* Position below navbar */
            right: 20px;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }

        .toast {
            min-width: 300px;
            padding: 16px;
            border-radius: 12px;
            background: rgba(17, 24, 39, 0.95);
            backdrop-filter: blur(8px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            display: flex;
            align-items: center;
            gap: 12px;
            transform: translateX(120%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: auto;
        }

        .toast.show {
            transform: translateX(0);
        }

        .toast-icon {
            width: 24px;
            height: 24px;
            flex-shrink: 0;
        }

        .toast-content {
            flex: 1;
        }

        .toast-title {
            font-weight: 600;
            color: #fff;
            margin-bottom: 4px;
        }

        .toast-message {
            color: #9ca3af;
            font-size: 0.875rem;
        }

        .toast-close {
            background: none;
            border: none;
            color: #9ca3af;
            cursor: pointer;
            padding: 4px;
            transition: color 0.2s;
        }

        .toast-close:hover {
            color: #fff;
        }

        .toast.success {
            border-left: 4px solid #10b981;
        }

        .toast.error {
            border-left: 4px solid #ef4444;
        }

        .toast.info {
            border-left: 4px solid #3b82f6;
        }

        .toast.warning {
            border-left: 4px solid #f59e0b;
        }

        /* Adjust main content to start after navbar */
        .main-content {
            margin-top: 60px; /* Height of navbar */
            padding-top: 1rem;
        }

        /* Add animation keyframes */
        @keyframes slideIn {
            from {
                transform: translateX(120%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(120%);
                opacity: 0;
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Selection mode styles */
        .selection-mode .document-item {
            position: relative;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 2px solid transparent;
            overflow: hidden;
        }

        .selection-mode .document-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(139, 92, 246, 0);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1;
        }

        .selection-mode .document-item:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
        }

        .selection-mode .document-item.selected {
            border-color: #8B5CF6;
            background: rgba(139, 92, 246, 0.05);
            box-shadow: 0 0 0 2px rgba(139, 92, 246, 0.3),
                       0 4px 12px rgba(139, 92, 246, 0.2);
            transform: translateY(-2px);
        }

        .selection-mode .document-item.selected::before {
            background: rgba(139, 92, 246, 0.1);
            animation: selectPulse 1.5s infinite;
        }

        .selection-mode .document-item.selected::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            color: #8B5CF6;
            font-size: 48px;
            font-weight: bold;
            opacity: 0;
            z-index: 2;
            animation: checkmarkAppear 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }

        .selection-mode .document-item.selected:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 0 0 2px rgba(139, 92, 246, 0.4),
                       0 8px 16px rgba(139, 92, 246, 0.3);
        }

        #multiSelectBtn.active {
            background: #8B5CF6;
            animation: buttonPulse 2s infinite;
        }

        @keyframes selectPulse {
            0% {
                box-shadow: 0 0 0 0 rgba(139, 92, 246, 0.4);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(139, 92, 246, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(139, 92, 246, 0);
            }
        }

        @keyframes checkmarkAppear {
            0% {
                transform: translate(-50%, -50%) scale(0);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.2);
                opacity: 0.5;
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        @keyframes buttonPulse {
            0% {
                box-shadow: 0 0 0 0 rgba(139, 92, 246, 0.4);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(139, 92, 246, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(139, 92, 246, 0);
            }
        }

        /* Add smooth transition for selection count */
        #multiSelectBtn span {
            transition: all 0.3s ease;
        }

        /* Add ripple effect on selection */
        .document-item::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 5px;
            height: 5px;
            background: rgba(139, 92, 246, 0.3);
            opacity: 0;
            border-radius: 100%;
            transform: scale(1, 1) translate(-50%);
            transform-origin: 50% 50%;
        }

        .document-item.selected::after {
            animation: ripple 0.6s ease-out;
        }

        @keyframes ripple {
            0% {
                transform: scale(0, 0);
                opacity: 0.5;
            }
            100% {
                transform: scale(20, 20);
                opacity: 0;
            }
        }

        /* Enhanced document selection styles */
        .document-item {
            position: relative;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 2px solid transparent;
            overflow: hidden;
            background: #1e293b;
            border-radius: 0.5rem;
            padding: 1rem;
            margin: 0.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .document-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border-color: #60a5fa;
        }

        .document-item.selected {
            border-color: #8B5CF6;
            background: rgba(139, 92, 246, 0.1);
            box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.4),
                       0 8px 16px rgba(139, 92, 246, 0.3);
            transform: translateY(-2px) scale(1.02);
            animation: selectedPulse 2s infinite;
        }

        @keyframes selectedPulse {
            0% {
                box-shadow: 0 0 0 0 rgba(139, 92, 246, 0.4),
                           0 8px 16px rgba(139, 92, 246, 0.3);
            }
            50% {
                box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.2),
                           0 8px 16px rgba(139, 92, 246, 0.3);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(139, 92, 246, 0.4),
                           0 8px 16px rgba(139, 92, 246, 0.3);
            }
        }

        .document-item.selected::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(139, 92, 246, 0.1);
            animation: selectedPulse 2s infinite;
            z-index: 1;
        }

        .document-item.selected::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            color: #8B5CF6;
            font-size: 48px;
            font-weight: bold;
            opacity: 0;
            z-index: 2;
            animation: checkmarkAppear 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }

        /* Drag and drop visual feedback */
        .document-item.dragging {
            opacity: 0.5;
            transform: scale(0.95);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
        }

        .folder-item.drag-over {
            background: rgba(96, 165, 250, 0.1);
            border: 2px dashed #60a5fa;
            animation: pulse 1s infinite;
        }

        /* Selection mode indicator */
        .selection-mode-indicator {
            position: fixed;
            top: 1rem;
            right: 1rem;
            background: #8B5CF6;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 9999px;
            box-shadow: 0 4px 6px rgba(139, 92, 246, 0.2);
            animation: slideIn 0.3s ease-out;
            z-index: 50;
        }

        /* Animations */
        @keyframes selectPulse {
            0% {
                box-shadow: 0 0 0 0 rgba(139, 92, 246, 0.4);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(139, 92, 246, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(139, 92, 246, 0);
            }
        }

        @keyframes checkmarkAppear {
            0% {
                transform: translate(-50%, -50%) scale(0);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.2);
                opacity: 0.5;
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.02);
            }
            100% {
                transform: scale(1);
            }
        }

        /* Selection bubble styles */
        .selection-bubble {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: rgba(139, 92, 246, 0.1);
            border: 2px solid transparent;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0;
            transform: scale(0);
        }

        .selection-bubble.selected {
            opacity: 1;
            transform: scale(1);
            background: #8B5CF6;
            border-color: white;
            box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.2);
        }

        .selection-bubble.selected::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 14px;
            font-weight: bold;
        }

        @keyframes selectPulse {
            0% {
                box-shadow: 0 0 0 0 rgba(139, 92, 246, 0.4);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(139, 92, 246, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(139, 92, 246, 0);
            }
        }

        @keyframes checkmarkAppear {
            0% {
                transform: translate(-50%, -50%) scale(0);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.2);
                opacity: 0.5;
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        @keyframes ripple {
            0% {
                transform: scale(0, 0);
                opacity: 0.5;
            }
            100% {
                transform: scale(20, 20);
                opacity: 0;
            }
        }

        /* Ripple effect styles */
        .ripple {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 5px;
            height: 5px;
            background: rgba(139, 92, 246, 0.3);
            opacity: 0;
            border-radius: 100%;
            transform: scale(1, 1) translate(-50%);
            transform-origin: 50% 50%;
            animation: ripple 0.6s ease-out;
        }

        /* Selection mode indicator */
        .selection-mode-indicator {
            position: fixed;
            top: 1rem;
            right: 1rem;
            background: #8B5CF6;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 9999px;
            box-shadow: 0 4px 6px rgba(139, 92, 246, 0.2);
            animation: slideIn 0.3s ease-out;
            z-index: 50;
        }

        @keyframes slideIn {
            from {
                transform: translateX(120%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(120%);
                opacity: 0;
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Modern select styling */
        select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: none;
        }

        select::-ms-expand {
            display: none;
        }

        /* Dropdown animation */
        @keyframes dropdownFade {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        select option {
            background-color: #1e293b;
            color: #e2e8f0;
            padding: 0.5rem;
            animation: dropdownFade 0.2s ease-out;
        }

        /* Sort icon animation */
        @keyframes sortIconPulse {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
            }
        }

        .fa-sort {
            animation: sortIconPulse 2s infinite;
        }
    </style>
</head>
<body class="bg-gray-100">
    <!-- Add toast container after body tag -->
    <div class="toast-container" id="toastContainer"></div>

    <div class="flex h-screen bg-slate-800">
        <!-- Left Sidebar - Folder Navigation (FolderSidebar style) -->
        <div class="w-80 bg-slate-900 flex flex-col border-r border-slate-700">
            <!-- Header -->
            <div class="p-4 border-b border-slate-700">
                <h2 class="text-white text-xl font-bold">DocDiL</h2>
                <div class="text-slate-400 text-sm" id="institutionName">Loading...</div>
            </div>
            
            <!-- Folder Tree Navigation -->
            <div class="flex-1 overflow-y-auto">
                <!-- Current Path Breadcrumb -->
                <div class="p-3 border-b border-slate-700">
                    <div class="flex items-center space-x-2 text-sm">
                        <button id="backToRoot" class="text-blue-400 hover:text-blue-300 transition-colors">
                            <i class="fas fa-home"></i>
                        </button>
                        <span class="text-slate-500">/</span>
                        <span id="currentPathBreadcrumb" class="text-slate-300">Root</span>
                    </div>
                </div>
                
                <!-- Folder Tree -->
                <div class="p-1">
                    <div id="folderTree" class="space-y-0.5">
                        <!-- Dynamic folder tree will be rendered here -->
                    </div>
                </div>
            </div>
            

            
            <!-- User info -->
            <div class="p-4 border-t border-slate-700">
                <div class="flex items-center space-x-3">
                    <div class="w-8 h-8 bg-blue-600 rounded-full flex items-center justify-center">
                        <i class="fas fa-user text-white text-sm"></i>
                    </div>
                    <div class="text-slate-300 text-sm">
                        <div id="userName">undefined undefined</div>
                        <div id="userInstitution" class="text-slate-500 text-xs">Scoala Dabuleni</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Content Area - Documents (similar to Diffuse.js) -->
        <div class="flex-1 bg-slate-800 overflow-auto">
            <!-- Header with Document Explorer styling -->
            <div class="bg-gradient-to-r from-purple-800 via-purple-700 to-indigo-700 px-6 py-4 border-b border-purple-600/30 rounded-xl rounded-l-none shadow-lg">
                <div class="flex items-center justify-between">
                    <div class="flex items-center space-x-4">
                        <div class="w-8 h-8 bg-white/20 rounded-lg flex items-center justify-center">
                            <i class="fas fa-folder text-white text-lg"></i>
                        </div>
                        <h1 class="text-xl font-bold text-white tracking-wide">Document Explorer</h1>
                        <div class="text-purple-200 text-sm" id="currentFolderInfo">Root</div>
                    </div>
                    <div class="flex items-center space-x-3">
                        <div class="relative">
                            <input
                                type="text"
                                placeholder="Căutare documente..."
                                class="bg-white/10 border border-white/20 rounded-lg px-4 py-2 text-white placeholder-purple-200 focus:bg-white/20 focus:border-white/40 transition-all duration-200 w-64"
                                id="documentSearch"
                            />
                            <i class="fas fa-search absolute right-3 top-3 text-purple-200"></i>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Content Area -->
            <div class="p-6">
                <!-- Upload controls -->
                <div class="mb-4 flex items-center gap-3" id="uploadControls">
                    <!-- Upload Button - Compact -->
                    <button id="openUploadCenterBtn" class="group relative px-4 py-2.5 bg-gradient-to-r from-purple-600 to-blue-600 text-white rounded-xl hover:from-purple-700 hover:to-blue-700 transition-all duration-300 shadow-lg hover:shadow-xl hover:scale-105" onclick="console.log('ONCLICK openUploadCenterBtn triggered'); if(typeof window.openUploadCenter === 'function') window.openUploadCenter('files'); else console.warn('openUploadCenter not available');" style="pointer-events: auto; z-index: 1000; position: relative;">
                        <div class="flex items-center gap-2">
                            <i class="fas fa-cloud-upload-alt text-sm"></i>
                            <span class="text-sm font-semibold">Upload</span>
                        </div>
                        <!-- Glow effect -->
                        <div class="absolute inset-0 rounded-xl bg-gradient-to-r from-purple-400 to-blue-400 blur-sm opacity-0 group-hover:opacity-30 transition-opacity duration-300 -z-10"></div>
                    </button>
                    
                    <!-- Open Institution Folder Button - Compact -->
                    <button id="openInstitutionFolderBtn" class="group relative px-4 py-2.5 bg-gradient-to-r from-emerald-600 to-teal-600 text-white rounded-xl hover:from-emerald-700 hover:to-teal-700 transition-all duration-300 shadow-lg hover:shadow-xl hover:scale-105" onclick="openInstitutionFolder()" style="pointer-events: auto; z-index: 1000; position: relative;">
                        <div class="flex items-center gap-2">
                            <i class="fas fa-folder-open text-sm"></i>
                            <span class="text-sm font-semibold">Folder</span>
                        </div>
                        <!-- Glow effect -->
                        <div class="absolute inset-0 rounded-xl bg-gradient-to-r from-emerald-400 to-teal-400 blur-sm opacity-0 group-hover:opacity-30 transition-opacity duration-300 -z-10"></div>
                    </button>
                    
                    <!-- hidden inputs for file selection -->
                    <input id="uploadFilesInput" type="file" multiple class="hidden" />
                </div>

                <!-- Upload Modal -->
                <div id="uploadModal" class="fixed inset-0 bg-black/60 hidden z-50" style="z-index:999999; pointer-events: auto;">
                    <div class="bg-slate-800 border border-slate-600 rounded-xl w-[820px] max-w-[95vw] mx-auto mt-24 p-6" style="pointer-events: auto;">
                        <div class="flex items-center justify-between mb-3">
                            <h3 class="text-white text-lg font-semibold">Upload Center</h3>
                            <button id="closeUploadModal" class="text-slate-300 hover:text-white" style="pointer-events: auto; cursor: pointer;" onclick="console.log('CLOSE MODAL ONCLICK'); document.getElementById('uploadModal').style.display = 'none'; document.getElementById('uploadModal').classList.add('hidden');"><i class="fas fa-times"></i></button>
                        </div>
                        <div class="flex items-center gap-2 mb-4">
                            <button id="tabFiles" class="px-3 py-1.5 rounded bg-blue-600 text-white" style="pointer-events: auto; cursor: pointer;" onclick="window.switchUploadTab('files');">PDF-uri</button>
                            <button id="tabFolders" class="px-3 py-1.5 rounded bg-slate-700 text-slate-200" style="pointer-events: auto; cursor: pointer;" onclick="window.switchUploadTab('folders');">Foldere</button>
                        </div>
                        <!-- Files Tab Content -->
                        <div id="filesTabContent" class="tab-content">
                            <div id="uploadDropArea" class="border-2 border-dashed border-slate-500 rounded-lg p-10 text-center text-slate-300 hover:border-blue-400 hover:bg-slate-700/20 transition-colors" style="pointer-events: auto;">
                                <i class="fas fa-cloud-upload-alt text-3xl mb-2"></i>
                                <div class="mb-2" id="dropHint">Trage și plasează PDF-uri aici</div>
                                <div class="text-slate-400 text-sm">sau</div>
                                <div class="mt-4 flex items-center justify-center gap-2">
                                    <button id="modalChooseFiles" class="px-3 py-2 bg-blue-600 text-white rounded hover:bg-blue-700" style="display: inline-block; pointer-events: auto; cursor: pointer;" onclick="window.selectFilesForUpload();">
                                        Alege PDF-uri
                                    </button>
                                </div>
                            </div>
                            
                            <!-- Selected Files Preview -->
                            <div id="selectedFilesPreview" class="mt-4 hidden">
                                <h4 class="text-white text-sm font-medium mb-2">Fișiere selectate:</h4>
                                <div id="selectedFilesList" class="bg-slate-700 rounded p-3 max-h-32 overflow-y-auto">
                                    <!-- Files will be listed here -->
                                </div>
                                <div class="flex items-center justify-between mt-3">
                                    <button id="clearSelectedFiles" class="px-3 py-1 bg-red-600 text-white rounded hover:bg-red-700 text-sm" style="pointer-events: auto; cursor: pointer;" onclick="window.clearSelectedFiles();">
                                        Șterge toate
                                    </button>
                                    <button id="startUploadFiles" class="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 font-medium" style="pointer-events: auto; cursor: pointer;" onclick="window.startUploadFiles();">
                                        <i class="fas fa-upload mr-1"></i> Upload
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- Folders Tab Content -->
                        <div id="foldersTabContent" class="tab-content" style="display: none;">
                            <div id="folderDropArea" class="border-2 border-dashed border-slate-500 rounded-lg p-6 text-center text-slate-300 hover:border-blue-400 hover:bg-slate-700/20 transition-colors mb-4" style="pointer-events: auto;">
                                <i class="fas fa-folder-plus text-2xl mb-2"></i>
                                <div class="mb-2">Trage și plasează foldere aici</div>
                                <div class="text-slate-400 text-xs mb-3">Target: <span id="folderTargetPath" class="text-blue-400"></span></div>
                                <button id="selectFolderBtn" class="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 text-sm" style="pointer-events: auto; cursor: pointer;" onclick="window.selectFolderForUpload();">
                                    Alege Folder
                                </button>
                            </div>

                            <!-- Selected Folders List -->
                            <div class="mt-4">
                                <div class="mb-3 flex justify-between items-center">
                                    <h4 class="text-slate-300 text-sm font-medium">Foldere selectate:</h4>
                                    <button onclick="window.clearSelectedFolders()" class="text-red-400 hover:text-red-300 text-xs" style="pointer-events: auto; cursor: pointer;">
                                        Șterge tot
                                    </button>
                                </div>
                                <div id="selectedFoldersPreview" class="space-y-2 max-h-64 overflow-y-auto">
                                    <!-- Selected folders will appear here -->
                                </div>
                            </div>

                            <!-- Upload Button -->
                            <div class="mt-4">
                                <button onclick="window.startUploadFolders()" id="uploadFoldersBtn" class="w-full px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:bg-gray-600 disabled:cursor-not-allowed" style="pointer-events: auto; cursor: pointer;" disabled>
                                    Upload Foldere (<span id="folderCount">0</span>)
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- Sync Progress Modal -->
                <div id="syncProgressModal" class="fixed inset-0 bg-black bg-opacity-50 z-50 hidden flex items-center justify-center">
                    <div class="bg-slate-800 rounded-lg p-6 max-w-md w-full mx-4 border border-slate-600">
                        <div class="text-center">
                            <div class="mb-4">
                                <div class="w-16 h-16 mx-auto bg-blue-900 rounded-full flex items-center justify-center">
                                    <svg class="w-8 h-8 text-blue-400 animate-spin" fill="none" viewBox="0 0 24 24">
                                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                    </svg>
                                </div>
                            </div>
                            <h3 class="text-lg font-semibold text-slate-200 mb-2" id="syncTitle">Sincronizare în curs...</h3>
                            <p class="text-slate-400 mb-4" id="syncStatus">Pregătirea sincronizării...</p>
                            
                            <!-- Progress Bar -->
                            <div class="w-full bg-slate-700 rounded-full h-2 mb-4">
                                <div class="bg-blue-500 h-2 rounded-full transition-all duration-300" id="syncProgressBar" style="width: 0%"></div>
                            </div>
                            
                            <!-- Stats -->
                            <div class="grid grid-cols-2 gap-4 text-sm">
                                <div class="bg-slate-700 rounded-lg p-3">
                                    <div class="text-slate-400">Foldere</div>
                                    <div class="font-semibold text-slate-200" id="foldersCount">0</div>
                                </div>
                                <div class="bg-slate-700 rounded-lg p-3">
                                    <div class="text-slate-400">Documente</div>
                                    <div class="font-semibold text-slate-200" id="documentsCount">0 / 0</div>
                                </div>
                            </div>
                            
                            <div class="mt-4 text-xs text-slate-500" id="currentFile">
                                Inițializare...
                            </div>
                            
                            <!-- Speed indicator -->
                            <div class="mt-2 text-xs text-slate-500" id="downloadSpeed">
                                Viteză: -
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Documents Grid -->
                <div id="documentsGrid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
                    <!-- Documents will be rendered here -->
                </div>
                
                <!-- Empty State -->
                <div id="emptyState" class="text-center py-12 text-slate-400">
                    <i class="fas fa-folder-open text-6xl mb-4 opacity-50"></i>
                    <h3 class="text-xl font-medium mb-2">No documents found</h3>
                    <p>Select a folder to view its documents</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Document Modal -->
    <div id="documentModal" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50">
        <div class="bg-white w-11/12 h-5/6 mx-auto mt-8 rounded-lg shadow-xl flex flex-col">
            <div class="flex justify-between items-center p-4 border-b">
                <h2 class="text-xl font-semibold text-gray-800">Detalii document</h2>
                <button class="text-gray-500 hover:text-gray-700" onclick="closeModal()">
                    <i class="fas fa-times text-xl"></i>
                </button>
            </div>
            <div class="flex flex-1 overflow-hidden">
                <!-- Document Details Sidebar -->
                <div class="w-64 bg-gray-50 p-4 overflow-y-auto">
                    <div class="space-y-3">
                        <div>
                            <div class="text-xs font-medium text-gray-500">Nume</div>
                            <div class="text-sm text-gray-800" id="documentName"></div>
                        </div>
                        <div>
                            <div class="text-xs font-medium text-gray-500">Tip</div>
                            <div class="text-sm text-gray-800" id="documentType"></div>
                        </div>
                        <div>
                            <div class="text-xs font-medium text-gray-500">Dimensiune</div>
                            <div class="text-sm text-gray-800" id="documentSize"></div>
                        </div>
                        <div>
                            <div class="text-xs font-medium text-gray-500">Data încărcării</div>
                            <div class="text-sm text-gray-800" id="documentUploadDate"></div>
                        </div>
                        <div>
                            <div class="text-xs font-medium text-gray-500">Comentariu</div>
                            <div class="text-sm text-gray-800" id="documentComment"></div>
                        </div>
                        <div>
                            <div class="text-xs font-medium text-gray-500">Cuvinte cheie</div>
                            <div class="text-sm text-gray-800" id="documentKeywords"></div>
                        </div>
                        <div>
                            <div class="text-xs font-medium text-gray-500">Tag-uri</div>
                            <div class="text-sm text-gray-800" id="documentTags"></div>
                        </div>
                    </div>
                </div>
                <!-- PDF Viewer --> 
                <div class="flex-1 bg-gray-100 p-4 relative">
                    <div id="pdfViewer" class="w-full h-full">
                        <div id="pdfPages" class="w-full h-full overflow-auto p-2 space-y-4"></div>
                    </div>
                    <div id="pdfError" class="hidden w-full h-full flex items-center justify-center">
                        <div class="text-center p-4">
                            <i class="fas fa-exclamation-circle text-red-500 text-4xl mb-2"></i>
                            <p class="text-gray-700">Nu s-a putut încărca previzualizarea documentului.</p>
                            <p class="text-sm text-gray-500 mt-1">Documentul poate fi mutat sau șters.</p>
                        </div>
                    </div>
                </div>
            </div>
            <div class="p-4 border-t flex justify-end">
                <button class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600 flex items-center" onclick="downloadCurrentDocument()">
                    <i class="fas fa-download mr-2"></i>
                    Descarcă
                </button>
            </div>
        </div>
    </div>

    <!-- Move Dialog -->
    <div id="moveDialog" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50">
        <div class="bg-gray-100 rounded-lg p-6 w-[800px] mx-auto mt-20">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-semibold text-gray-800">Mutați elemente</h3>
                <button id="closeMoveDialog" class="text-gray-500 hover:text-gray-700">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <!-- Breadcrumb Navigation -->
            <div id="moveDialogBreadcrumb" class="flex items-center space-x-2 mb-4 text-sm bg-white p-2 rounded-lg shadow-sm">
                <button class="text-blue-600 hover:text-blue-700 font-medium" onclick="navigateToRootInMoveDialog()">
                    <i class="fas fa-home"></i> Root (radacina)
                </button>
                <!-- Breadcrumb items will be added here dynamically -->
            </div>

            <!-- Folder Navigation -->
            <div class="grid grid-cols-2 gap-4">
                <!-- Left side: Folder Tree -->
                <div class="border rounded-lg p-4 bg-white h-[400px] overflow-y-auto shadow-sm">
                    <h4 class="font-medium text-gray-800 mb-3 pb-2 border-b">Foldere disponibile</h4>
                    <div id="moveDialogFolders" class="space-y-2">
                        <!-- Folders will be added here dynamically -->
                    </div>
                </div>

                <!-- Right side: Selected Items -->
                <div class="border rounded-lg p-4 bg-white h-[400px] overflow-y-auto shadow-sm">
                    <h4 class="font-medium text-gray-800 mb-3 pb-2 border-b">Elemente selectate</h4>
                    <div id="moveDialogSelectedItems" class="space-y-2">
                        <!-- Selected items will be shown here -->
                    </div>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="flex justify-end space-x-2 mt-4">
                <button id="cancelMove" class="px-4 py-2 text-gray-600 hover:text-gray-800 bg-white rounded-lg shadow-sm hover:shadow">
                    Anulează
                </button>
                <button id="confirmMove" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 shadow-sm hover:shadow">
                    Mutați aici
                </button>
            </div>
        </div>
    </div>

    <script>
        const { ipcRenderer } = require('electron');
        let currentFolder = null;
        let currentPath = '';
        // Declare early so it exists before any handlers reference it
        let isMoveDialogOpen = false;
        
        // Ensure Upload controls are visible only inside a folder (not at Root)
        function updateUploadControlsVisibility() {
            try {
                const controls = document.getElementById('uploadControls');
                if (!controls) return;
                
                // Check multiple sources for current path
                const breadcrumb = document.getElementById('currentFolderInfo');
                const breadcrumbText = breadcrumb ? breadcrumb.textContent.trim() : '';
                
                // SIMPLE: if breadcrumb contains "/" then we're in a subfolder
                const inSubfolder = breadcrumbText.includes('/');
                

                
                // Show button if we're in any subfolder (breadcrumb has "/")
                controls.style.display = inSubfolder ? 'flex' : 'none';
                
                // Also update currentFolderPath for upload modal
                if (inSubfolder && breadcrumbText !== 'Root') {
                    window.currentFolderPath = breadcrumbText;
                }
            } catch (e) { console.warn('updateUploadControlsVisibility error', e); }
        }
        
        // Initial run and hook into folder navigation
        setTimeout(updateUploadControlsVisibility, 100);
        
        // Hook into folder click events to update visibility
        document.addEventListener('click', function(e) {
            if (e.target.closest('.folder-item') || e.target.closest('[data-folder]') || e.target.textContent.includes('Folder')) {
                setTimeout(updateUploadControlsVisibility, 200);
            }
        });
        
        // Add Drag & Drop support to upload modal
        document.addEventListener('DOMContentLoaded', function() {
            const folderDropArea = document.getElementById('folderDropArea');
            
            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            // NOTE: uploadDropArea listeners are set up separately in the main initialization
            // to avoid conflicts with the functional drag & drop logic
            
            // Setup drag & drop for FOLDERS area
            if (folderDropArea) {
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    folderDropArea.addEventListener(eventName, preventDefaults, false);
                });
                
                // Visual feedback for folders
                ['dragenter', 'dragover'].forEach(eventName => {
                    folderDropArea.addEventListener(eventName, () => {
                        folderDropArea.classList.add('ring', 'ring-blue-400', 'bg-slate-700/30');
                    });
                });
                
                ['dragleave', 'drop'].forEach(eventName => {
                    folderDropArea.addEventListener(eventName, () => {
                        folderDropArea.classList.remove('ring', 'ring-blue-400', 'bg-slate-700/30');
                    });
                });
                
                // Handle folder drops
                folderDropArea.addEventListener('drop', async (e) => {
                    console.log('[FOLDER] Drop event in folderDropArea');
                    const files = e.dataTransfer.files;
                    
                    if (files && files.length > 0) {
                        for (let i = 0; i < files.length; i++) {
                            const item = files[i];
                            console.log('[FOLDER] Dropped item:', item.name, 'path:', item.path, 'type:', item.type);
                            
                            // Check if it's a directory (empty type usually indicates directory in Electron)
                            if (item.path && (!item.type || item.type === '')) {
                                try {
                                    const fs = require('fs');
                                    const stat = fs.statSync(item.path);
                                    
                                    if (stat.isDirectory()) {
                                        console.log('[FOLDER] Valid directory dropped:', item.path);
                                        
                                        const folderName = item.name;
                                        const folderPath = item.path;
                                        
                                        // Check if folder already selected
                                        const existingIndex = window.selectedFolders.findIndex(f => f.path === folderPath);
                                        if (existingIndex === -1) {
                                            window.selectedFolders.push({
                                                name: folderName,
                                                path: folderPath,
                                                expanded: false,
                                                files: []
                                            });
                                            
                                            // Scan folder for PDF files
                                            await window.scanFolderContents(folderPath, window.selectedFolders.length - 1);
                                            window.updateSelectedFoldersPreview();
                                        } else {
                                            console.log('[FOLDER] Folder already selected:', folderName);
                                        }
                                    }
                                } catch (error) {
                                    console.error('[FOLDER] Error processing dropped item:', error);
                                }
                            }
                        }
                    }
                });
            }
        });

        // HOIST: make upload modal openers available immediately for inline onclick
        window.openUploadModal = function(mode) {
            try {
                console.log('[UPLOAD][HOIST] openUploadModal called with mode:', mode);
                const modal = document.getElementById('uploadModal');
                if (!modal) return console.warn('[UPLOAD][HOIST] #uploadModal not found');
                modal.classList.remove('hidden');
                modal.style.display = 'flex';
            } catch (e) { console.error('openUploadModal error:', e); }
        }
        
        // Global arrays to store selected files and folders (separate per tab)
        window.selectedFiles = [];
        window.selectedFolders = [];
        window.currentUploadTab = 'files'; // Track active tab
        
        // Flag to prevent multiple initializations
        window.pdfDragDropInitialized = false;
        
        window.initializePDFDragDrop = function() {
            if (window.pdfDragDropInitialized) {
                console.log('[UPLOAD] PDF drag & drop already initialized, skipping');
                return;
            }
            
            const dropArea = document.getElementById('uploadDropArea');
            if (!dropArea) {
                console.log('[UPLOAD] uploadDropArea not found, cannot initialize drag & drop');
                return;
            }
            
            console.log('[UPLOAD] Initializing PDF drag & drop listeners on uploadDropArea');
            
            // Add preventDefaults for ALL events (like folder does)
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                }, false);
            });
            
            // Visual feedback for drag enter/over  
            ['dragenter','dragover'].forEach(ev => dropArea.addEventListener(ev, e => { 
                console.log('[UPLOAD] Drag event:', ev);
                dropArea.classList.add('ring','ring-blue-400'); 
            }));
            
            // Visual feedback removal for dragleave and drop
            ['dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, () => {
                    dropArea.classList.remove('ring', 'ring-blue-400');
                });
            });
            
            // Handle PDF drops (separate from visual feedback)
            dropArea.addEventListener('drop', (e) => {
                console.log('[UPLOAD] Drop in uploadDropArea');
                
                const dt = e.dataTransfer;
                if (!dt) return;
                
                const droppedFiles = [];
                
                // Prefer items (support folders); fallback to files
                const items = dt.items ? Array.from(dt.items) : [];
                
                if (items.length) {
                    console.log('[UPLOAD] Processing items:', items.length);
                    items.forEach(it => {
                        if (it.kind === 'file') {
                            const f = it.getAsFile();
                            if (!f) return;
                            console.log('[UPLOAD] File:', f.name, 'path:', f.path);
                            if (!/\.pdf$/i.test(f.name)) {
                                console.log('[UPLOAD] Skipping non-PDF:', f.name);
                                return;
                            }
                            if (!f.path) {
                                console.log('[UPLOAD] No file path for:', f.name);
                                return;
                            }
                            droppedFiles.push(f.path);
                        }
                    });
                } else if (dt.files) {
                    console.log('[UPLOAD] Processing files:', dt.files.length);
                    Array.from(dt.files).forEach(f => { 
                        console.log('[UPLOAD] File:', f.name, 'path:', f.path);
                        if (/\.pdf$/i.test(f.name) && f.path) {
                            droppedFiles.push(f.path);
                        }
                    });
                }
                
                // Add dropped files to selection and show preview
                if (droppedFiles.length > 0) {
                    window.selectedFiles = [...window.selectedFiles, ...droppedFiles];
                    window.updateSelectedFilesPreview();
                    console.log('[UPLOAD] Added', droppedFiles.length, 'files to selection');
                }
            });
            
            window.pdfDragDropInitialized = true;
            console.log('[UPLOAD] PDF drag & drop initialized successfully');
        };
        
        window.selectFilesForUpload = async function() {
            try {
                console.log('[UPLOAD] selectFilesForUpload called');
                
                // Set target path for upload
                const currentPath = window.currentFolderPath || '';
                window.uploadTargetPath = currentPath;
                console.log('[UPLOAD] Set target path:', currentPath);
                
                const { ipcRenderer } = require('electron');
                const res = await ipcRenderer.invoke('select-upload-files');
                if (res && !res.canceled && res.paths && res.paths.length > 0) {
                    const newFiles = res.paths.filter(p => /\.pdf$/i.test(p));
                    // ADD to existing files instead of replacing
                    if (!window.selectedFiles) window.selectedFiles = [];
                    newFiles.forEach(file => {
                        if (!window.selectedFiles.includes(file)) {
                            window.selectedFiles.push(file);
                        }
                    });
                    window.updateSelectedFilesPreview();
                    
                    // Show success notification
                    showToast({
                        title: 'Files Added',
                        message: `${newFiles.length} file(s) added to staging area`,
                        type: 'success',
                        duration: 2000
                    });
                }
            } catch (err) {
                console.error('File selection failed:', err);
            }
        }
        
        window.selectFolderForUpload = async function() {
            try {
                console.log('[UPLOAD] selectFolderForUpload called');
                const { ipcRenderer } = require('electron');
                const res = await ipcRenderer.invoke('select-upload-folder');
                if (res && !res.canceled && res.path) {
                    // Stage folder instead of instant upload
                    const pathMod = require('path');
                    if (!Array.isArray(window.selectedFolders)) window.selectedFolders = [];
                    const folderName = pathMod.basename(res.path);
                    if (!window.selectedFolders.some(f => f && f.path === res.path)) {
                        window.selectedFolders.push({ path: res.path, name: folderName });
                    }
                    window.updateSelectedFilesPreview();
                    showToast({ title: 'Folder added', message: `${folderName} added to staging`, type: 'success', duration: 2000 });
                }
            } catch (err) {
                console.error('Folder selection failed:', err);
            }
        }
        
        window.updateSelectedFilesPreview = function() {
            const preview = document.getElementById('selectedFilesPreview');
            const filesList = document.getElementById('selectedFilesList');
            
            if (!window.selectedFiles || window.selectedFiles.length === 0) {
                preview.classList.add('hidden');
                return;
            }
            
            preview.classList.remove('hidden');
            const fileItems = (window.selectedFiles || []).map((filePath, index) => {
                const fileName = filePath.split(/[\\/]/).pop();
                return `
                    <div class="flex items-center justify-between py-1 px-2 bg-slate-600 rounded mb-1">
                        <div class="flex items-center">
                            <i class="fas fa-file-pdf text-red-400 mr-2"></i>
                            <span class="text-white text-sm">${fileName}</span>
                        </div>
                        <button onclick="window.removeSelectedFile(${index})" class="text-slate-400 hover:text-red-400">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                `;
            }).join('');

            filesList.innerHTML = fileItems;
        }
        
        window.removeSelectedFile = function(index) {
            window.selectedFiles.splice(index, 1);
            window.updateSelectedFilesPreview();
        }

        window.removeSelectedFolder = function(index) {
            window.selectedFolders.splice(index, 1);
            window.updateSelectedFoldersPreview();
        }
        
        window.updateSelectedFoldersPreview = function() {
            const preview = document.getElementById('selectedFoldersPreview');
            
            if (!window.selectedFolders || window.selectedFolders.length === 0) {
                preview.innerHTML = '<div class="text-slate-400 text-sm text-center py-4">Nu există foldere selectate</div>';
                // Update folder count
                const folderCountSpan = document.getElementById('folderCount');
                const uploadBtn = document.getElementById('uploadFoldersBtn');
                if (folderCountSpan) folderCountSpan.textContent = '0';
                if (uploadBtn) uploadBtn.disabled = true;
                return;
            }
            
            const folderItems = (window.selectedFolders || []).map((folder, fidx) => {
                const folderName = (folder && (folder.name || folder.path.split(/[\\/]/).pop())) || 'Folder';
                return `
                    <div class="flex items-center justify-between py-2 px-3 bg-slate-700 rounded mb-2">
                        <div class="flex items-center">
                            <i class="fas fa-folder text-yellow-400 mr-3"></i>
                            <span class="text-white text-sm">${folderName}</span>
                        </div>
                        <button onclick="window.removeSelectedFolder(${fidx})" class="text-slate-400 hover:text-red-400">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                `;
            }).join('');

            preview.innerHTML = folderItems;
            
            // Update folder count and enable upload button
            const folderCountSpan = document.getElementById('folderCount');
            const uploadBtn = document.getElementById('uploadFoldersBtn');
            if (folderCountSpan) folderCountSpan.textContent = window.selectedFolders.length;
            if (uploadBtn) uploadBtn.disabled = false;
        }
        
        window.clearSelectedFiles = function() {
            if (window.currentUploadTab === 'files') {
                window.selectedFiles = [];
                window.updateSelectedFilesPreview();
            } else {
                window.selectedFolders = [];
                window.updateSelectedFoldersPreview();
            }
        }
        
        window.clearSelectedFolders = function() {
            window.selectedFolders = [];
            window.updateSelectedFoldersPreview();
        }
        
        // Tab switching function
        window.switchUploadTab = function(tabName) {
            window.currentUploadTab = tabName;
            
            // Update tab buttons
            const tabFiles = document.getElementById('tabFiles');
            const tabFolders = document.getElementById('tabFolders');
            const filesContent = document.getElementById('filesTabContent');
            const foldersContent = document.getElementById('foldersTabContent');
            
            if (tabName === 'files') {
                tabFiles.className = 'px-3 py-1.5 rounded bg-blue-600 text-white';
                tabFolders.className = 'px-3 py-1.5 rounded bg-slate-700 text-slate-200';
                filesContent.style.display = 'block';
                foldersContent.style.display = 'none';
            } else {
                tabFiles.className = 'px-3 py-1.5 rounded bg-slate-700 text-slate-200';
                tabFolders.className = 'px-3 py-1.5 rounded bg-blue-600 text-white';
                filesContent.style.display = 'none';
                foldersContent.style.display = 'block';
            }
            
            // Update previews based on current tab
            if (tabName === 'files') {
                window.updateSelectedFilesPreview();
            } else {
                window.updateSelectedFoldersPreview();
            }
        }

        window.startUploadFiles = function() {
            const isFilesTab = window.currentUploadTab === 'files';
            const isFoldersTab = window.currentUploadTab === 'folders';
            
            if (isFilesTab && (!window.selectedFiles || window.selectedFiles.length === 0)) {
                showToast({ title: 'Nu există fișiere', message: 'Adaugă PDF-uri pentru a le încărca', type: 'warning', duration: 2000 });
                return;
            }
            
            if (isFoldersTab && (!window.selectedFolders || window.selectedFolders.length === 0)) {
                showToast({ title: 'Nu există foldere', message: 'Adaugă foldere pentru a le încărca', type: 'warning', duration: 2000 });
                return;
            }
            
            const targetPath = (window.uploadTargetPath || window.currentFolderPath || '').replace(/^\/+|\/+$/g, '');
            console.log('[UPLOAD] Starting upload with targetPath:', targetPath);
            console.log('[UPLOAD] Current tab:', window.currentUploadTab);
            
            const { ipcRenderer } = require('electron');
            
            // Process files only if on files tab
            if (isFilesTab && window.selectedFiles && window.selectedFiles.length > 0) {
                window.selectedFiles.forEach(filePath => {
                    const parts = filePath.split(/[\\\/]/);
                    const base = parts[parts.length - 1] || 'document.pdf';
                    console.log('[UPLOAD] 🚀🚀🚀 Processing file:', base, 'to targetPath:', targetPath);
                    
                    // 🆕 OPTIMISTIC UPLOAD: Add document to UI instantly
                    if (window.currentFolderPath === targetPath) {
                        console.log('🎯 [OPTIMISTIC UPLOAD] Adding document to UI instantly:', base);
                        
                        // Create optimistic document object
                        const optimisticDoc = {
                            id: Date.now(), // Temporary ID
                            name: base,
                            path: targetPath,
                            type: 'Official Document',
                            uploadDate: new Date().toISOString(),
                            size: 0,
                            uploadedBy: 'System',
                            tags: [],
                            mot1: null,
                            mot2: null,
                            mot3: null,
                            mot4: null,
                            mot5: null
                        };
                        
                        // Add to cache and UI instantly (ensure structure exists)
                        if (!Array.isArray(window.lastDocuments)) window.lastDocuments = [];
                        // Prevent duplicate visuals if same name already present optimistically
                        window.lastDocuments = [optimisticDoc, ...window.lastDocuments.filter(d => d?.name !== optimisticDoc.name)];
                        renderDocumentsGrid(window.lastDocuments);
                        console.log('✅ [OPTIMISTIC UPLOAD] Document added to UI instantly');
                    }
                    
                    ipcRenderer.send('process-file', { 
                        filePath, 
                        targetPath, 
                        fileName: base, 
                        fileType: 'application/pdf', 
                        fileSize: 0 
                    });
                });
            }

            // Process folders only if on folders tab
            if (isFoldersTab && window.selectedFolders && window.selectedFolders.length > 0) {
                window.selectedFolders.forEach(folder => {
                    if (folder && folder.path) {
                        ipcRenderer.send('add-folder', { folderPath: folder.path, targetPath });
                    }
                });
            }

            // Show success message
            const fileCount = isFilesTab ? (window.selectedFiles || []).length : 0;
            const folderCount = isFoldersTab ? (window.selectedFolders || []).length : 0;
            
            showToast({
                title: 'Upload Started',
                message: `Uploading ${fileCount} file(s) and ${folderCount} folder(s) to ${targetPath || 'Root'}...`,
                type: 'info',
                duration: 3000
            });
            
            // Clear selection and close modal
            if (isFilesTab) {
                window.selectedFiles = [];
                window.updateSelectedFilesPreview();
            } else {
                window.selectedFolders = [];
                window.updateSelectedFoldersPreview();
            }
            
            document.getElementById('uploadModal').style.display = 'none';
            document.getElementById('uploadModal').classList.add('hidden');
        }
        
        // Add folder upload function
        window.startUploadFolders = function() {
            return window.startUploadFiles(); // Use the same function but it will check the current tab
        }
        
        // === FOLDER FUNCTIONALITY ===
        
        // Enhanced folder selection functionality
        window.selectFolderForUpload = async function() {
            try {
                console.log('[FOLDER] selectFolderForUpload called');
                const { ipcRenderer } = require('electron');
                const res = await ipcRenderer.invoke('select-upload-folder');
                console.log('[FOLDER] Selected folder result:', res);
                
                if (res && !res.canceled && res.filePaths?.[0]) {
                    const folderPath = res.filePaths[0];
                    console.log('[FOLDER] Processing folder path:', folderPath);
                    
                    // Add to selected folders array
                    const folderName = folderPath.split('/').pop() || folderPath.split('\\').pop();
                    
                    // Check if folder already selected
                    const existingIndex = window.selectedFolders.findIndex(f => f.path === folderPath);
                    if (existingIndex === -1) {
                        window.selectedFolders.push({
                            name: folderName,
                            path: folderPath,
                            expanded: false,
                            files: []
                        });
                        
                        // Scan folder for PDF files
                        await window.scanFolderContents(folderPath, window.selectedFolders.length - 1);
                        window.updateSelectedFoldersPreview();
                    } else {
                        console.log('[FOLDER] Folder already selected');
                    }
                }
            } catch (error) {
                console.error('[FOLDER] Error selecting folder:', error);
            }
        };
        
        // Scan folder for PDF files recursively
        window.scanFolderContents = async function(folderPath, folderIndex) {
            try {
                console.log('[FOLDER] Scanning contents of:', folderPath);
                const fs = require('fs');
                const path = require('path');
                
                function scanFolder(dirPath, relativePath = '') {
                    const files = [];
                    try {
                        const items = fs.readdirSync(dirPath, { withFileTypes: true });
                        
                        for (const item of items) {
                            const fullPath = path.join(dirPath, item.name);
                            const relPath = path.join(relativePath, item.name);
                            
                            if (item.isDirectory()) {
                                // Recursively scan subdirectories
                                const subFiles = scanFolder(fullPath, relPath);
                                files.push(...subFiles);
                            } else if (item.isFile() && item.name.toLowerCase().endsWith('.pdf')) {
                                files.push({
                                    name: item.name,
                                    fullPath: fullPath,
                                    relativePath: relPath,
                                    size: fs.statSync(fullPath).size
                                });
                            }
                        }
                    } catch (error) {
                        console.error('[FOLDER] Error scanning folder:', dirPath, error);
                    }
                    return files;
                }
                
                const files = scanFolder(folderPath);
                window.selectedFolders[folderIndex].files = files;
                console.log(`[FOLDER] Found ${files.length} PDF files in folder:`, folderPath);
                
            } catch (error) {
                console.error('[FOLDER] Error scanning folder contents:', error);
            }
        };
        
        // Update folders preview
        window.updateSelectedFoldersPreview = function() {
            const preview = document.getElementById('selectedFoldersPreview');
            const folderCount = document.getElementById('folderCount');
            const uploadBtn = document.getElementById('uploadFoldersBtn');
            
            if (!preview) return;
            
            folderCount.textContent = window.selectedFolders.length;
            uploadBtn.disabled = window.selectedFolders.length === 0;
            
            if (window.selectedFolders.length === 0) {
                preview.innerHTML = '<div class="text-slate-400 text-sm italic">Niciun folder selectat</div>';
                return;
            }
            
            preview.innerHTML = window.selectedFolders.map((folder, index) => `
                <div class="bg-slate-700 rounded p-3 border border-slate-600">
                    <div class="flex items-center justify-between">
                        <div class="flex items-center flex-1">
                            <button onclick="window.toggleFolderExpansion(${index})" class="text-slate-300 hover:text-white mr-2" style="pointer-events: auto; cursor: pointer;">
                                <i class="fas fa-chevron-${folder.expanded ? 'down' : 'right'}"></i>
                            </button>
                            <i class="fas fa-folder text-yellow-400 mr-2"></i>
                            <span class="text-slate-200 font-medium">${folder.name}</span>
                            <span class="text-slate-400 text-xs ml-2">(${folder.files.length} PDF-uri)</span>
                        </div>
                        <button onclick="window.removeSelectedFolder(${index})" class="text-red-400 hover:text-red-300 ml-2" style="pointer-events: auto; cursor: pointer;">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    
                    ${folder.expanded ? `
                        <div class="mt-2 ml-6 space-y-1">
                            ${folder.files.length === 0 ? 
                                '<div class="text-slate-400 text-xs">Niciun PDF găsit</div>' :
                                folder.files.slice(0, 10).map((file, fileIndex) => `
                                    <div class="flex items-center justify-between bg-slate-800 rounded px-2 py-1">
                                        <div class="flex items-center flex-1">
                                            <i class="fas fa-file-pdf text-red-400 mr-2 text-xs"></i>
                                            <span class="text-slate-300 text-xs truncate">${file.relativePath}</span>
                                        </div>
                                        <button onclick="window.removeFileFromFolder(${index}, ${fileIndex})" class="text-red-400 hover:text-red-300 ml-2" style="pointer-events: auto; cursor: pointer;">
                                            <i class="fas fa-times text-xs"></i>
                                        </button>
                                    </div>
                                `).join('') +
                                (folder.files.length > 10 ? `<div class="text-slate-400 text-xs">... și încă ${folder.files.length - 10} fișiere</div>` : '')
                            }
                        </div>
                    ` : ''}
                </div>
            `).join('');
        };
        
        // Toggle folder expansion
        window.toggleFolderExpansion = function(index) {
            if (window.selectedFolders[index]) {
                window.selectedFolders[index].expanded = !window.selectedFolders[index].expanded;
                window.updateSelectedFoldersPreview();
            }
        };
        
        // Remove selected folder
        window.removeSelectedFolder = function(index) {
            window.selectedFolders.splice(index, 1);
            window.updateSelectedFoldersPreview();
        };
        
        // Remove file from folder
        window.removeFileFromFolder = function(folderIndex, fileIndex) {
            if (window.selectedFolders[folderIndex] && window.selectedFolders[folderIndex].files[fileIndex]) {
                window.selectedFolders[folderIndex].files.splice(fileIndex, 1);
                window.updateSelectedFoldersPreview();
            }
        };
        
        // Clear all selected folders
        window.clearSelectedFolders = function() {
            window.selectedFolders = [];
            window.updateSelectedFoldersPreview();
        };
        
        // Start upload folders
        window.startUploadFolders = async function() {
            if (window.selectedFolders.length === 0) return;
            
            try {
                const targetPath = window.uploadTargetPath || window.currentFolderPath || '';
                console.log('[FOLDER] Starting folder upload with target path:', targetPath);
                
                for (const folder of window.selectedFolders) {
                    console.log('[FOLDER] Uploading folder:', folder.name, 'with', folder.files.length, 'files');
                    
                    // Use existing IPC handler for folder upload
                    console.log('🚀 [RENDERER] About to send add-folder IPC event');
                    console.log('🚀 [RENDERER] Folder path:', folder.path);
                    console.log('🚀 [RENDERER] Target path:', targetPath);
                    
                    ipcRenderer.send('add-folder', {
                        folderPath: folder.path,
                        targetPath: targetPath
                    });
                    
                    console.log('🚀 [RENDERER] add-folder IPC event sent successfully');
                }
                
                // Clear after successful upload
                window.clearSelectedFolders();
                
                // Close modal
                document.getElementById('uploadModal').style.display = 'none';
                document.getElementById('uploadModal').classList.add('hidden');
                
            } catch (error) {
                console.error('[FOLDER] Error uploading folders:', error);
                alert('Eroare la upload: ' + error.message);
            }
        };
        window.openUploadCenter = function(initialTab = 'files') {
            try {
                console.log('[UPLOAD][HOIST] openUploadCenter called with tab:', initialTab);
                
                // ===== CRITICAL: DETECT CURRENT FOLDER PATH =====
                let detectedPath = '';
                
                // 1. Try window.currentFolderPath first
                console.log('[UPLOAD DEBUG] window.currentFolderPath value:', window.currentFolderPath);
                console.log('[UPLOAD DEBUG] typeof window.currentFolderPath:', typeof window.currentFolderPath);
                
                if (window.currentFolderPath) {
                    detectedPath = window.currentFolderPath;
                    console.log('[UPLOAD] Using window.currentFolderPath:', detectedPath);
                } else {
                    // 2. Try all possible selectors to find current path
                    const selectors = [
                        '.breadcrumb-item',
                        '.location-folder', 
                        '[data-current-path]',
                        '#currentPath',
                        '#currentPathBreadcrumb',
                        '.breadcrumb span',
                        '.path-item',
                        '.folder-path'
                    ];
                    
                    let found = false;
                    for (const selector of selectors) {
                        const elements = document.querySelectorAll(selector);
                        console.log('[UPLOAD DEBUG] Selector:', selector, '- Found:', elements.length, 'elements');
                        
                        if (elements.length > 0) {
                            for (let i = 0; i < elements.length; i++) {
                                console.log('[UPLOAD DEBUG]', selector, i, ':', elements[i].textContent?.trim() || elements[i].getAttribute?.('data-current-path'));
                            }
                        }
                    }
                    
                    // 3. Use the currentPathBreadcrumb detection if found
                    const currentPathElement = document.getElementById('currentPathBreadcrumb');
                    if (currentPathElement && currentPathElement.textContent.trim()) {
                        const folderName = currentPathElement.textContent.trim();
                        console.log('[UPLOAD DEBUG] Found currentPathBreadcrumb:', folderName);
                        
                        // Check if we're at root level (breadcrumb shows "Root")
                        if (folderName === 'Root') {
                            // We're at institution root level - no subfolder
                            const institutionName = window.userData?.institution_name || 'Scoala Dabuleni';
                            detectedPath = institutionName;
                            console.log('[UPLOAD] At root level, using institution only:', detectedPath);
                            found = true;
                        } else {
                            // We're in a specific subfolder
                            const institutionName = window.userData?.institution_name || 'Scoala Dabuleni';
                            detectedPath = `${institutionName}/${folderName}`;
                            console.log('[UPLOAD] Constructed path from breadcrumb:', detectedPath);
                            found = true;
                        }
                    }
                    
                    // 4. Try header text - look for pattern "Scoala Dabuleni/something"
                    if (!found) {
                        const headerElements = document.querySelectorAll('h1, h2, h3, .header, .title, .path-display');
                        console.log('[UPLOAD DEBUG] Header elements found:', headerElements.length);
                        
                        for (let i = 0; i < headerElements.length; i++) {
                            const headerText = headerElements[i].textContent?.trim();
                            console.log('[UPLOAD DEBUG] Header', i, ':', headerText);
                            
                            // Look for pattern like "Scoala Dabuleni/folder"
                            if (headerText && headerText.includes('/') && headerText !== 'Root') {
                                const parts = headerText.split('/');
                                if (parts.length > 1) {
                                    detectedPath = headerText;
                                    console.log('[UPLOAD] Detected from header:', detectedPath);
                                    found = true;
                                    break;
                                }
                            }
                        }
                    }
                    
                    if (!found) {
                        detectedPath = '';
                        console.log('[UPLOAD] Could not detect current path - defaulting to root');
                    }
                }
                
                // Set the detected path globally for upload modal use
                window.uploadTargetPath = detectedPath;
                console.log('[UPLOAD] Set uploadTargetPath to:', window.uploadTargetPath);
                
                const modal = document.getElementById('uploadModal');
                if (!modal) return console.warn('[UPLOAD][HOIST] #uploadModal not found');
                modal.classList.remove('hidden');
                modal.style.display = 'flex';
                
                // ===== TAB SWITCHING LOGIC =====
                const isFiles = (initialTab || 'files') === 'files';
                const tabF = document.getElementById('tabFiles');
                const tabD = document.getElementById('tabFolders');
                const filesContent = document.getElementById('filesTabContent');
                const foldersContent = document.getElementById('foldersTabContent');
                const hint = document.getElementById('dropHint');
                const folderHint = document.getElementById('folderTargetPath');
                
                // Switch tab appearance
                if (tabF && tabD) {
                    if (isFiles) {
                        tabF.className = 'px-3 py-1.5 rounded bg-blue-600 text-white';
                        tabD.className = 'px-3 py-1.5 rounded bg-slate-700 text-slate-200';
                    } else {
                        tabF.className = 'px-3 py-1.5 rounded bg-slate-700 text-slate-200';
                        tabD.className = 'px-3 py-1.5 rounded bg-blue-600 text-white';
                    }
                }
                
                // Switch tab content
                if (filesContent && foldersContent) {
                    if (isFiles) {
                        filesContent.style.display = 'block';
                        foldersContent.style.display = 'none';
                        
                        // Initialize PDF drag & drop when tab becomes visible
                        window.initializePDFDragDrop();
                    } else {
                        filesContent.style.display = 'none';
                        foldersContent.style.display = 'block';
                    }
                }
                
                // Update hints with target path
                if (hint) hint.textContent = isFiles ? 
                    `Trage și plasează PDF-uri aici (în ${detectedPath || 'Root'})` :
                    'Trage și plasează PDF-uri aici';
                if (folderHint) folderHint.textContent = detectedPath || 'Root';
                const chooseFiles = document.getElementById('modalChooseFiles');
                const chooseFolder = document.getElementById('modalChooseFolder');
                if (tabF && tabD && hint) {
                    if (isFiles) {
                        tabF.className = 'px-3 py-1.5 rounded bg-blue-600 text-white';
                        tabD.className = 'px-3 py-1.5 rounded bg-slate-700 text-slate-200';
                        hint.textContent = `Trage și plasează PDF-uri aici${detectedPath ? ` (în ${detectedPath})` : ' (în Root)'}`;
                        if (chooseFiles) chooseFiles.style.display = 'inline-block';
                        if (chooseFolder) chooseFolder.style.display = 'none';
                    } else {
                        tabD.className = 'px-3 py-1.5 rounded bg-blue-600 text-white';
                        tabF.className = 'px-3 py-1.5 rounded bg-slate-700 text-slate-200';
                        hint.textContent = `Trage și plasează foldere aici${detectedPath ? ` (în ${detectedPath})` : ' (în Root)'}`;
                        if (chooseFiles) chooseFiles.style.display = 'none';
                        if (chooseFolder) chooseFolder.style.display = 'inline-block';
                    }
                }
            } catch (e) { console.error('openUploadCenter error:', e); }
        }

        // File system events are now handled by renderer.js

        ipcRenderer.on('recentFilesUpdate', (event, files) => {
            console.log('=== Received recentFilesUpdate ===');
            console.log('Files:', files);
            updateRecentFilesList(files);
        });

        ipcRenderer.on('folderContentsUpdate', (event, data) => {
            console.log('=== Received folderContentsUpdate ===');
            console.log('Update data:', data);
            
            if (currentFolder && currentFolder.folder_path === data.path) {
                updateFolderContents(data.contents);
            }
        });

        // UNIFIED listener for real-time document updates (ONLY from main process IPC)
        ipcRenderer.on('fileSystemUpdate', async (event, data) => {
            console.log('\n=== UNIFIED fileSystemUpdate HANDLER (IPC ONLY) ===');
            console.log('Update data:', JSON.stringify(data, null, 2));
            
            try {
                // UNIFIED MOVE EVENT PROCESSING - Single operation for all move events
                let eventKey;
                if (data.type === 'move') {
                    // Create unified move key that works across all event types (move_source, move_target, electron_move)
                    const documentName = data.documentName || 'unknown';
                    const sourcePath = data.sourcePath || data.sourceFolder || '';
                    const targetPath = data.targetFolder || data.targetPath || '';
                    const timestamp = data.timestamp || new Date().toISOString();
                    
                    // NORMALIZE DOCUMENT NAME - Remove .pdf extension for consistent comparison
                    const normalizeDocumentName = (name) => {
                        if (!name || name === 'unknown') return 'unknown';
                        // Remove .pdf extension if present
                        return name.toLowerCase().replace(/\.pdf$/i, '');
                    };
                    
                    // Normalize paths to extract folder names consistently
                    const normalizePath = (path) => {
                        if (!path) return '';
                        let normalized = path.replace(/\\/g, '/').toLowerCase();
                        
                        // Extract just the institution/folder part from absolute paths
                        if (normalized.includes('/uploads/')) {
                            const parts = normalized.split('/uploads/');
                            if (parts.length > 1) {
                                normalized = parts[1];
                            }
                        }
                        
                        // Remove any remaining absolute path parts
                        if (normalized.includes('/users/') || normalized.includes('/desktop/')) {
                            const pathParts = normalized.split('/');
                            // Find the institution name (usually after the long path)
                            const institutionIndex = pathParts.findIndex(part => part.includes('dabuleni'));
                            if (institutionIndex !== -1) {
                                normalized = pathParts.slice(institutionIndex).join('/');
                            }
                        }
                        
                        return normalized;
                    };
                    
                    const normalizedDocName = normalizeDocumentName(documentName);
                    const sourceFolder = normalizePath(sourcePath);
                    const targetFolder = normalizePath(targetPath);
                    
                    // Create unified move key that ignores eventType differences
                    eventKey = `unified_move_${normalizedDocName}_${sourceFolder}_${targetFolder}`;
                } else {
                    eventKey = `${data.type}_${data.documentName || 'unknown'}_${data.timestamp}_${data.targetFolder}`;
                }
                
                if (window.processedEvents && window.processedEvents.has(eventKey)) {
                    console.log('🔄 Skipping duplicate event:', eventKey);
                    return;
                }
                
                // Initialize processed events set if it doesn't exist
                if (!window.processedEvents) {
                    window.processedEvents = new Set();
                }
                
                // Add this event to processed set
                window.processedEvents.add(eventKey);
                console.log('✅ Added event to processed set:', eventKey);
                
                // Clean up old events after 3 seconds to catch all related events
                setTimeout(() => {
                    if (window.processedEvents) {
                        window.processedEvents.delete(eventKey);
                        console.log('🧹 Cleaned up event:', eventKey);
                    }
                }, 3000);
                
                // SIMPLIFIED PROCESSING - No rate limiting, just deduplication
                
                // Extract folder paths for comparison (returns full relative path)
                const extractFolderPath = (path) => {
                    if (!path) return '';
                    
                    // Case 1: Path is already a relative path from institution root
                    // e.g., "Scoala Dabuleni/GERTE" or "GERTE"
                    if (path.includes('Scoala Dabuleni') && !path.includes('/uploads/') && !path.includes('/users/')) {
                        return path;
                    }
                    
                    // Case 2: Path is just a folder name (e.g., "GERTE")
                    // Prepend the institution name to form the full relative path
                    if (!path.includes('/') && window.userData && window.userData.institution_name) {
                        return `${window.userData.institution_name}/${path}`;
                    }
                    
                    // Case 3: Path is a full file system path (absolute)
                    // Extract the relative part after uploads
                    const uploadsIndex = path.indexOf('/uploads/');
                    if (uploadsIndex !== -1) {
                        const pathAfterUploads = path.substring(uploadsIndex + '/uploads/'.length);
                        const parts = pathAfterUploads.split('/');
                        if (parts.length > 1 && parts[parts.length - 1].includes('.')) { // It's a file path
                            return parts.slice(0, -1).join('/'); // Return folder path
                        }
                        return pathAfterUploads; // It's already a folder path
                    }
                    
                    // Case 4: Path contains absolute system paths
                    if (path.includes('/users/') || path.includes('/desktop/')) {
                        const pathParts = path.split('/');
                        // Find the institution name in the path
                        const institutionIndex = pathParts.findIndex(part => part.includes('dabuleni'));
                        if (institutionIndex !== -1) {
                            const relativePath = pathParts.slice(institutionIndex).join('/');
                            // Remove file name if present
                            if (relativePath.includes('.')) {
                                return relativePath.split('/').slice(0, -1).join('/');
                            }
                            return relativePath;
                        }
                    }
                    
                    // Fallback: return as is
                    return path;
                };
                
                // Get current folder path from multiple sources
                let currentPath = '';
                
                // 1. Try window.currentFolderPath first
                if (window.currentFolderPath) {
                    currentPath = window.currentFolderPath;
                    console.log('🎯 Using window.currentFolderPath:', currentPath);
                } else {
                    // 2. Try breadcrumb analysis
                    const breadcrumb = document.getElementById('currentPathBreadcrumb');
                    if (breadcrumb && breadcrumb.textContent !== 'Root') {
                        currentPath = breadcrumb.textContent;
                        console.log('🔄 Using breadcrumb path:', currentPath);
                    }
                }
                
                // 3. If we have institution name, construct full path
                if (currentPath && window.userData && window.userData.institution_name) {
                    // Check if path already includes institution name
                    if (!currentPath.includes(window.userData.institution_name)) {
                        currentPath = `${window.userData.institution_name}/${currentPath}`;
                        console.log('🏢 Constructed full path with institution:', currentPath);
                    }
                }
                
                console.log('📍 Current folder path:', currentPath);
                console.log('🎯 Event target folder:', data.targetFolder);
                
                // Handle different types of file system updates
                if (data.type === 'move' && (data.documentName || data.sourcePath)) {
                    console.log('🔄 Document moved:', data.documentName || 'Unknown');
                    console.log('From:', data.sourcePath);
                    console.log('To:', data.targetFolder);
                    
                    // Extract folder paths for comparison
                    const sourceFolder = extractFolderPath(data.sourcePath);
                    const targetFolder = extractFolderPath(data.targetFolder);
                    
                    console.log('🔍 Source folder:', sourceFolder);
                    console.log('🔍 Target folder:', targetFolder);
                    console.log('🔍 Current folder:', currentPath);
                    
                    // 🆕 OPTIMISTIC UPDATE: Instant UI update like React
                    console.log('✅ [OPTIMISTIC] Move operation detected - applying instant optimistic update');
                    
                    // 🆕 LOCK HTTP CALLS: Prevent HTTP from overriding optimistic updates
                    // BUT only for document moves, not folder moves
                    if (!window.optimisticLock && data.documentName && data.documentName !== 'Unknown') {
                        window.optimisticLock = {
                            active: true,
                            operation: 'move',
                            documentName: data.documentName,
                            timestamp: Date.now(),
                            timeout: null
                        };
                        
                        // Auto-release lock after 3 seconds for better performance
                        window.optimisticLock.timeout = setTimeout(() => {
                            if (window.optimisticLock) {
                                console.log('🔓 [OPTIMISTIC] Auto-releasing lock after timeout');
                                window.optimisticLock = null;
                            }
                        }, 3000); // Optimized timeout for better performance
                        
                        console.log('🔒 [OPTIMISTIC] Locked HTTP calls to prevent override');
                    }
                    
                    // 🆕 INSTANT CACHE UPDATE: Update cache immediately without UI refresh
                    if (currentPath === sourceFolder) {
                        console.log('🔄 [OPTIMISTIC] Updating source folder cache instantly:', sourceFolder);
                        
                        // Remove moved document from cache immediately
                        if (window.lastDocuments && window.lastDocuments.length > 0) {
                            const updatedDocuments = window.lastDocuments.filter(doc => 
                                doc.name !== data.documentName && 
                                doc.name !== data.documentName?.replace('.pdf', '')
                            );
                            
                            if (updatedDocuments.length !== window.lastDocuments.length) {
                                console.log('✅ [OPTIMISTIC] Removed moved document from cache instantly');
                                window.lastDocuments = updatedDocuments;
                                
                                // 🆕 SILENT UI UPDATE: Update UI without refresh
                                renderDocumentsGrid(updatedDocuments);
                                console.log('✅ [OPTIMISTIC] UI updated instantly without refresh');
                            }
                        }
                    }
                    
                    if (currentPath === targetFolder) {
                        console.log('🔄 [OPTIMISTIC] Updating target folder cache instantly:', targetFolder);
                        
                        // Add moved document to cache immediately
                        if (window.lastDocuments && window.lastDocuments.length > 0) {
                            const movedDocument = {
                                id: Date.now(), // Temporary ID
                                name: data.documentName || 'Unknown',
                                path: targetFolder,
                                type: 'Official Document',
                                uploadDate: new Date().toISOString(),
                                size: 0,
                                uploadedBy: 'System',
                                tags: [],
                                mot1: null,
                                mot2: null,
                                mot3: null,
                                mot4: null,
                                mot5: null
                            };
                            
                            const updatedDocuments = [movedDocument, ...window.lastDocuments];
                            console.log('✅ [OPTIMISTIC] Added moved document to cache instantly');
                            window.lastDocuments = updatedDocuments;
                            
                            // 🆕 SILENT UI UPDATE: Update UI without refresh
                            renderDocumentsGrid(updatedDocuments);
                            console.log('✅ [OPTIMISTIC] UI updated instantly without refresh');
                        }
                    }
                    
                    // 🆕 KEEP LOCK ACTIVE: Don't release lock immediately to prevent HTTP override
                    console.log('🔒 [OPTIMISTIC] Lock kept active to prevent HTTP override');
                    
                    // 🆕 NO REFRESH NEEDED: Cache updated instantly like React
                    console.log('🎯 [OPTIMISTIC] Move operation completed with instant cache update - no refresh');
                    
                    // 🆕 NOTIFY REACT: Send notification to React about folder updates
                    if (typeof window.notifyReactAboutFolderUpdate === 'function') {
                        // Notify about source folder (document removed)
                        if (sourceFolder) {
                            window.notifyReactAboutFolderUpdate(sourceFolder, 'move_source', data.documentName);
                        }
                        // Notify about target folder (document added)
                        if (targetFolder) {
                            window.notifyReactAboutFolderUpdate(targetFolder, 'move_target', data.documentName);
                        }
                    }
                    
                    // Optimized grace period for backend to complete the move, then reconcile
                    setTimeout(async () => {
                        try {
                            // Refresh source folder (where document was removed)
                            if (currentPath === sourceFolder) {
                                console.log('🔄 Refreshing source folder (document removed):', sourceFolder);
                                
                                if (window.userData && window.userData.institution_id) {
                                    const sourceResult = await window.electron.ipcRenderer.invoke('load-documents-for-folder', sourceFolder);
                                    console.log('📦 Source folder load result:', sourceResult);
                                    
                                    if (sourceResult.success && sourceResult.documents) {
                                        console.log(`✅ Source folder: Found ${sourceResult.documents.length} documents, refreshing UI...`);
                                        renderDocumentsGrid(sourceResult.documents);
                                        console.log('✅ Source folder refreshed after move operation');
                                    } else {
                                        console.log('⚠️ Source folder: No documents returned, showing empty state');
                                        renderDocumentsGrid([]);
                                    }
                                }
                            }
                            
                            // Refresh target folder (where document was added)
                            if (currentPath === targetFolder) {
                                console.log('🔄 Refreshing target folder (document added):', targetFolder);
                                
                                if (window.userData && window.userData.institution_id) {
                                    const targetResult = await window.electron.ipcRenderer.invoke('load-documents-for-folder', targetFolder);
                                    console.log('📦 Target folder load result:', targetResult);
                                    
                                    if (targetResult.success && targetResult.documents) {
                                        console.log(`✅ Target folder: Found ${targetResult.documents.length} documents, refreshing UI...`);
                                        renderDocumentsGrid(targetResult.documents);
                                        console.log('✅ Target folder refreshed after move operation');
                                        // Remove any optimistic placeholders
                                        try {
                                            const grid = document.getElementById('documentsGrid');
                                            if (grid) Array.from(grid.querySelectorAll('[data-temp="true"]').forEach(el => el.remove()));
                                        } catch {}
                                    } else {
                                        console.log('⚠️ Target folder: No documents returned, showing empty state');
                                        renderDocumentsGrid([]);
                                    }
                                }
                            }
                            
                            // UNIFIED MOVE HANDLER - No redundant refresh, rely on optimistic updates
                            console.log('🎯 [UNIFIED MOVE] Move operation completed - no redundant refresh needed');
                            
                        } catch (error) {
                            console.error('❌ Error refreshing folders after move operation:', error);
                        } finally {
                            // No processing flag to clear - simplified logic
                        }
                    }, 1000); // 1 second delay (unified reconciliation)
                } else if (data.type === 'add' || data.type === 'delete') {
                    console.log('🔄 File added/deleted:', data.type);
                    
                    // Extract target folder path
                    const targetFolder = extractFolderPath(data.targetFolder);
                    console.log('🔍 Target folder:', targetFolder);
                    console.log('🔍 Current folder:', currentPath);
                    
                    // 🆕 OPTIMISTIC UPDATE: No refresh needed, just cache update like React
                    console.log('🎯 [OPTIMISTIC] File added/deleted - no refresh needed, just cache update');

                    // If this event was initiated by Electron, do not lock HTTP or block UI refresh
                    if (data && data.fromElectron) {
                        console.log('🔄 [ELECTRON] Skipping optimistic lock for Electron-originated add/delete');
                    } else {
                        // 🆕 LOCK HTTP CALLS: Prevent HTTP from overriding optimistic updates
                        if (!window.optimisticLock) {
                            window.optimisticLock = {
                                active: true,
                                operation: data.type,
                                documentName: 'unknown',
                                timestamp: Date.now(),
                                timeout: null
                            };
                            
                            // Auto-release lock after 8 seconds to prevent HTTP override
                            window.optimisticLock.timeout = setTimeout(() => {
                                if (window.optimisticLock) {
                                    console.log('🔓 [OPTIMISTIC] Auto-releasing lock after timeout');
                                    window.optimisticLock = null;
                                }
                            }, 8000);
                            
                            console.log('🔒 [OPTIMISTIC] Locked HTTP calls to prevent override');
                        }
                    }
                    
                    // 🆕 INSTANT CACHE UPDATE: Update cache immediately without UI refresh
                    if (data.type === 'add') {
                        console.log('🔄 [OPTIMISTIC] Document added - updating cache instantly');
                        // Cache will be updated by the next folder load, no refresh needed
                    } else if (data.type === 'delete') {
                        console.log('🔄 [OPTIMISTIC] Document deleted - updating cache instantly');
                        // Cache will be updated by the next folder load, no refresh needed
                    }
                    
                    // 🆕 KEEP LOCK ACTIVE: Don't release lock immediately to prevent HTTP override
                    console.log('🔒 [OPTIMISTIC] Lock kept active to prevent HTTP override');
                    
                    // 🆕 NO REFRESH NEEDED: Cache updated instantly like React
                    console.log('🎯 [OPTIMISTIC] Add/Delete operation completed with instant cache update - no refresh');
                }
                
                // Show notification to user (only for meaningful events - reduce spam)
                if (data.type === 'folder_create' && data.folderName && !eventKey.includes('unknown')) {
                    showToast({
                        title: 'Folder Created',
                        message: `Folder "${data.folderName}" created with documents`,
                        type: 'success',
                        duration: 2500
                    });
                    console.log('✅ Folder toast displayed for event:', eventKey);
                }
                
            } catch (error) {
                console.error('❌ Error handling fileSystemUpdate:', error);
            }
        });

        async function loadFolderContents(folder) {
            console.log('=== Loading folder contents ===');
            console.log('Folder:', folder);
            
            try {
                currentFolder = folder;
                currentPath = folder.folder_path;
                
                // Request folder contents from main process
                ipcRenderer.send('get-folder-contents', {
                    path: folder.folder_path,
                    institutionId: folder.institution_id
                });
            } catch (error) {
                console.error('Error loading folder contents:', error);
            }
        }

        async function loadRecentFiles() {
            console.log('=== Loading recent files ===');
            try {
                ipcRenderer.send('get-recent-files');
            } catch (error) {
                console.error('Error loading recent files:', error);
            }
        }

        function updateRecentFilesList(files) {
            const recentFilesContainer = document.getElementById('recent-files');
            if (!recentFilesContainer) return;

            recentFilesContainer.innerHTML = '';
            
            if (!files || files.length === 0) {
                recentFilesContainer.innerHTML = '<p>Nu există fișiere recente</p>';
                return;
            }

            const fileList = document.createElement('ul');
            fileList.className = 'file-list';

            files.forEach(file => {
                const listItem = document.createElement('li');
                listItem.className = 'file-item';
                listItem.innerHTML = `
                    <span class="file-name">${file.name}</span>
                    <span class="file-date">${new Date(file.uploadDate).toLocaleString()}</span>
                `;
                fileList.appendChild(listItem);
            });

            recentFilesContainer.appendChild(fileList);
        }

        function updateFolderContents(contents) {
            const folderContentsContainer = document.getElementById('folder-contents');
            if (!folderContentsContainer) return;

            folderContentsContainer.innerHTML = '';
            
            if (!contents || contents.length === 0) {
                folderContentsContainer.innerHTML = '<p>Nu există fișiere în acest folder</p>';
                return;
            }

            const fileList = document.createElement('ul');
            fileList.className = 'file-list';

            contents.forEach(file => {
                const listItem = document.createElement('li');
                listItem.className = 'file-item';   
                listItem.innerHTML = `
                    <span class="file-name">${file.name}</span>
                    <span class="file-date">${new Date(file.uploadDate).toLocaleString()}</span>
                `;
                fileList.appendChild(listItem);
            });

            folderContentsContainer.appendChild(fileList);
        }

        // Track expanded folders globally - DEFINE EARLY
        let expandedFolders = new Set();
        
        // 🎯 DEFINE displayFolders EARLY - BEFORE ANY OTHER CODE
        window.displayFolders = function(data) {
            console.log('🎨 Using new UI to display folders and documents', data);
            
            // 🆕 DUPLICATE CALL PROTECTION: Prevent multiple calls with same data
            const dataKey = JSON.stringify(data);
            if (window.lastDisplayData === dataKey) {
                console.log('🔄 [DUPLICATE] Skipping duplicate displayFolders call with same data');
                return;
            }
            window.lastDisplayData = dataKey;
            
            // 🆕 OPTIMISTIC LOCK CHECK: Respect optimistic updates
            if (window.optimisticLock && window.optimisticLock.active) {
                const lockOperation = window.optimisticLock.operation;
                const documentName = window.optimisticLock.documentName;
                
                // Allow refresh for folder moves, block only for document moves
                if (lockOperation === 'move' && documentName && documentName !== 'Unknown' && documentName !== 'FolderMove') {
                    console.log('🔒 [OPTIMISTIC] HTTP call blocked by optimistic lock for document move:', documentName);
                    console.log('🔒 [OPTIMISTIC] Lock details:', {
                        operation: window.optimisticLock.operation,
                        documentName: window.optimisticLock.documentName,
                        timestamp: new Date(window.optimisticLock.timestamp).toISOString()
                    });
                    console.log('🔒 [OPTIMISTIC] Complete UI protection - no cache update, no UI change');
                    return; // Exit early to prevent ANY override
                } else {
                    console.log('🔄 [OPTIMISTIC] Allowing refresh for folder move or non-move operation:', lockOperation);
                }
            }
            
            // Store data globally for other functions
            window.lastFolderData = data;
            
            // Update institution name
            const institutionNameEl = document.getElementById('institutionName');
            if (institutionNameEl && data.institutionName) {
                institutionNameEl.textContent = data.institutionName;
            }
            
            // Render folder tree in sidebar
            renderFolderTree(data.folders || [], data.currentPath || '');
            
            // Render documents in main area (preserve existing documents if preserveDocuments flag is set)
            if (data.preserveDocuments && window.lastDocuments && window.lastDocuments.length > 0) {
                console.log('🎨 [PRESERVE] Keeping existing documents:', window.lastDocuments.length);
                renderDocumentsGrid(window.lastDocuments);
            } else {
                console.log('🎨 [RENDER] Rendering new documents:', data.documents?.length || 0);
                
                // Don't render empty documents if we have existing documents (preserve them)
                if ((!data.documents || data.documents.length === 0) && window.lastDocuments && window.lastDocuments.length > 0) {
                    console.log('🎨 [PRESERVE] Skipping empty documents, keeping existing:', window.lastDocuments.length);
                    renderDocumentsGrid(window.lastDocuments);
                } else if (data.documents && data.documents.length > 0) {
                    // Only render if we have actual documents
                    renderDocumentsGrid(data.documents);
                    // Store current documents for preservation
                    window.lastDocuments = data.documents;
                    console.log('💾 [STORE] Stored documents for preservation:', window.lastDocuments.length);
                } else {
                    // No documents to render
                    console.log('🎨 [RENDER] No documents to render');
                    renderDocumentsGrid([]);
                }
            }
            
            // Update user info if available
            updateUserInfo();
        };
        console.log('✅ window.displayFolders defined early');

        // Initialize WebSocket when the page loads
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('=== Dashboard initialized ===');
            
            // 🆕 REACT NOTIFICATION SYSTEM: Notify React about specific folder updates
            window.notifyReactAboutFolderUpdate = function(folderPath, operationType, documentName) {
                try {
                    console.log('🔄 [REACT NOTIFY] Sending folder update notification:', {
                        folderPath: folderPath,
                        operationType: operationType,
                        documentName: documentName,
                        timestamp: new Date().toISOString()
                    });
                    
                    // Create a detailed update event for React
                    const updateEvent = {
                        type: 'sync-agent-folder-update',
                        folderPath: folderPath,
                        operationType: operationType,
                        documentName: documentName,
                        timestamp: new Date().toISOString(),
                        source: 'sync-agent'
                    };
                    
                    // Method 1: localStorage (cross-origin communication)
                    localStorage.setItem('sync-agent-folder-update', JSON.stringify(updateEvent));
                    // Remove it immediately to trigger subsequent events
                    setTimeout(() => {
                        localStorage.removeItem('sync-agent-folder-update');
                    }, 100);
                    
                    // Method 2: CustomEvent (same-origin communication)
                    window.dispatchEvent(new CustomEvent('sync-agent-folder-update', { detail: updateEvent }));
                    
                    // Method 3: postMessage (cross-frame communication, e.g., if React is in an iframe)
                    window.parent.postMessage(updateEvent, '*'); // Send to parent window
                    
                    console.log('✅ [REACT NOTIFY] Folder update notification sent successfully');
                } catch (error) {
                    console.error('❌ [REACT NOTIFY] Error sending folder update notification:', error);
                }
            };
            
            try {
                // First load user info
                const userData = await window.electron.ipcRenderer.invoke('get-user-info');
                if (userData) {
                    console.log('\n=== DEBUG: User data loaded ===');
                    console.log('DEBUG: User data:', JSON.stringify(userData, null, 2));
                    document.getElementById('userName').textContent = `${userData.firstName} ${userData.lastName}`;
                    
                    // Display correct institution/personal folder name
                    const displayName = userData.institution_id 
                        ? userData.institution_name 
                        : (userData.personal_folder_name || 'Personal Account');
                    document.getElementById('userInstitution').textContent = displayName;
                    // Store user data globally
                    window.userData = userData;
                    
                    // WebSocket is initialized by renderer.js
                    console.log('\n=== DEBUG: User data loaded, WebSocket handled by renderer.js ===');
                    console.log('DEBUG: User ID:', userData.id);
                    console.log('DEBUG: Institution ID:', userData.institution_id);
                    
                    // Request folder structure
                    window.electron.ipcRenderer.send('get-folder-structure', {
                        institutionId: userData.institution_id,
                        currentPath: ''
                    });
                } else {
                    console.error('Failed to load user data');
                }
            } catch (error) {
                console.error('Error during initialization:', error);
            }
        });

        // Expose ipcRenderer to window object
        window.electron = {
            ipcRenderer: require('electron').ipcRenderer
        };

        // Function to open institution folder
        window.openInstitutionFolder = async function() {
            try {
                console.log('Opening institution folder...');
                const result = await window.electron.ipcRenderer.invoke('open-edms-folder');
                if (result.success) {
                    console.log('✅ Institution folder opened successfully:', result.path);
                } else {
                    console.warn('⚠️ Failed to open institution folder:', result.message);
                    alert('Nu s-a putut deschide folderul instituției: ' + result.message);
                }
            } catch (error) {
                console.error('❌ Error opening institution folder:', error);
                alert('Eroare la deschiderea folderului instituției: ' + error.message);
            }
        };

        let folderHistory = [];
        let documentRows = [];
        let currentDocument = null;
        let currentPdfDoc = null;
        let reconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 5;

        // Add path module at the top
        const path = require('path');

        // WebSocket initialization is now handled by renderer.js

        // Handle folder selection (removed - element doesn't exist in new UI)
        const selectFolderBtn = document.getElementById('selectFolder');
        if (selectFolderBtn) {
            selectFolderBtn.addEventListener('click', () => {
                window.electron.ipcRenderer.send('select-folder');
            });
        }

        // Handle back button (check if exists)
        const backBtn = document.getElementById('backButton');
        if (backBtn) {
            backBtn.addEventListener('click', () => {
            if (folderHistory.length > 0) {
                const previousFolder = folderHistory.pop();
                updateBreadcrumb(previousFolder);
                
                // Set current folder path globally
                window.currentFolderPath = previousFolder;
                console.log('DEBUG: Set window.currentFolderPath to:', previousFolder);
                
                window.electron.ipcRenderer.send('get-folder-structure', {
                    institutionId: window.userData.institution_id,
                    currentPath: previousFolder
                });
            }
        });
        }

        function navigateToRoot() {
            currentFolder = null;
            folderHistory = [];
            updateBreadcrumb('');
            
            // Set current folder path globally
            window.currentFolderPath = '';
            console.log('DEBUG: Set window.currentFolderPath to root (empty string)');
            
            window.electron.ipcRenderer.send('get-folder-structure', {
                institutionId: window.userData.institution_id,
                currentPath: ''
            });
        }

        function navigateToFolder(folderPath) {
            console.log('Navigating to folder:', folderPath);
            // Remove leading slash if present
            const cleanPath = folderPath.startsWith('/') ? folderPath.substring(1) : folderPath;
            window.electron.ipcRenderer.send('get-folder-structure', {
                institutionId: window.userData.institution_id,
                currentPath: cleanPath
            });
        }

        function updateBreadcrumb(currentPath) {
            const locationPath = document.getElementById('location-path');
            
            // Clear existing path items except Root
            while (locationPath.children.length > 1) {
                locationPath.removeChild(locationPath.lastChild);
            }

            if (currentPath) {
                const pathParts = currentPath.split('/').filter(Boolean);
                let builtPath = '';
                
                pathParts.forEach((part, index) => {
                    if (part) {
                        builtPath += '/' + part;
                        
                        // Add separator
                        const separator = document.createElement('span');
                        separator.className = 'location-separator';
                        separator.innerHTML = '<i class="fas fa-chevron-right"></i>';
                        locationPath.appendChild(separator);
                        
                        // Add path part
                        const folder = document.createElement('span');
                        folder.className = 'location-folder';
                        folder.textContent = part;
                        locationPath.appendChild(folder);
                    }
                });
            }
            
            // Update back button state
            document.getElementById('backButton').disabled = folderHistory.length === 0;
        }

        function findFolderByPath(path) {
            // This function will be implemented to find a folder by its path
            return null; // Placeholder
        }

        // Function to format file size
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Function to format date
        function formatDate(dateString) {
            if (!dateString) return 'N/A';
            const date = new Date(dateString);
            return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
        }

        // Function to render PDF
        async function renderPDF(pdfPath) {
            try {
                console.log('Attempting to render PDF from path:', pdfPath);
                const canvas = document.getElementById('pdfCanvas');
                const ctx = canvas.getContext('2d');

                // Read the PDF file using the new handler
                const pdfBuffer = await window.electron.ipcRenderer.invoke('read-pdf-file', pdfPath);
                if (!pdfBuffer) {
                    throw new Error('Could not read PDF file');
                }

                // Load the PDF using the buffer
                const loadingTask = pdfjsLib.getDocument({ data: pdfBuffer });
                const pdf = await loadingTask.promise;
                
                // Get the first page
                const page = await pdf.getPage(1);
                
                // Set scale to fit the canvas width
                const viewport = page.getViewport({ scale: 1.5 });
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                
                // Render the page
                await page.render({
                    canvasContext: ctx,
                    viewport: viewport
                }).promise;
                
                console.log('PDF rendered successfully');
            } catch (error) {
                console.error('Error rendering PDF:', error);
                const canvas = document.getElementById('pdfCanvas');
                const ctx = canvas.getContext('2d');
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Set canvas size
                canvas.width = 400;
                canvas.height = 200;
                
                // Draw error message
                ctx.fillStyle = '#ff0000';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Error loading PDF', canvas.width / 2, canvas.height / 2);
            }
        }

        // Add this near the top of your script section, with other global variables
        let selectedDocuments = new Set();

        function createDocumentElement(doc) {
            const docElement = document.createElement('div');
            docElement.className = 'relative group bg-gray-800 rounded-xl shadow-lg hover:shadow-xl transition-all duration-300 border border-gray-700 hover:border-blue-500 transform hover:-translate-y-1';
            docElement.dataset.documentId = doc.id;
            docElement.dataset.documentPath = doc.path;
            docElement.dataset.documentName = doc.name;

            // Add selection bubble
            const selectionBubble = document.createElement('div');
            selectionBubble.className = 'selection-bubble';
            docElement.appendChild(selectionBubble);

            // Document content wrapper
            const content = document.createElement('div');
            content.className = 'p-4';

            // Document metadata header with ovals
            const metadata = document.createElement('div');
            metadata.className = 'flex items-center space-x-2 mb-3';
            metadata.innerHTML = `
                <div class="flex items-center px-2 py-1 bg-blue-900/50 rounded-full text-xs text-blue-300">
                    <svg class="w-3 h-3 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                    ${formatDate(doc.uploadDate)}
                </div>
                <div class="flex items-center px-2 py-1 bg-purple-900/50 rounded-full text-xs text-purple-300">
                    <svg class="w-3 h-3 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                    </svg>
                    ${formatFileSize(doc.size)}
                </div>
            `;

            // Document icon and name section
            const header = document.createElement('div');
            header.className = 'flex items-center space-x-3 mb-4';

            // Document icon
            const icon = document.createElement('div');
            icon.className = 'flex-shrink-0 w-10 h-10 bg-blue-900/50 rounded-lg flex items-center justify-center group-hover:bg-blue-900/70 transition-colors duration-300';
            icon.innerHTML = `
                <svg class="w-6 h-6 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z"></path>
                </svg>
            `;

            // Document info
            const info = document.createElement('div');
            info.className = 'flex-1 min-w-0';

            // Document name with truncation
            const name = document.createElement('h3');
            name.className = 'text-base font-medium text-white truncate group-hover:text-blue-400 transition-colors duration-300';
            name.textContent = doc.name;

            // Action buttons container
            const actions = document.createElement('div');
            actions.className = 'flex items-center justify-end space-x-2 mt-3 pt-3 border-t border-gray-700';

            // View button
            const viewButton = document.createElement('button');
            viewButton.className = 'p-1.5 text-gray-400 hover:text-blue-400 hover:bg-blue-900/30 rounded-lg transition-all duration-300 transform hover:scale-110';
            viewButton.title = 'View Document';
            viewButton.innerHTML = `
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path>
                </svg>
            `;
            viewButton.onclick = (e) => {
                e.stopPropagation();
                showDocumentDetails(doc);
            };

            // Download button
            const downloadButton = document.createElement('button');
            downloadButton.className = 'p-1.5 text-gray-400 hover:text-green-400 hover:bg-green-900/30 rounded-lg transition-all duration-300 transform hover:scale-110';
            downloadButton.title = 'Download Document';
            downloadButton.innerHTML = `
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
                </svg>
            `;
            downloadButton.onclick = (e) => {
                e.stopPropagation();
                downloadDocument(doc.id);
            };

            // Move button
            const moveButton = document.createElement('button');
            moveButton.className = 'p-1.5 text-gray-400 hover:text-purple-400 hover:bg-purple-900/30 rounded-lg transition-all duration-300 transform hover:scale-110';
            moveButton.title = 'Move Document';
            moveButton.innerHTML = `
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4"></path>
                </svg>
            `;
            moveButton.onclick = (e) => {
                e.stopPropagation();
                showMoveDialog([{
                    type: 'document',
                    id: doc.id,
                    name: doc.name,
                    path: doc.path
                }]);
            };

            // Assemble the document card
            info.appendChild(name);
            header.appendChild(icon);
            header.appendChild(info);
            content.appendChild(metadata);
            content.appendChild(header);
            actions.appendChild(viewButton);
            actions.appendChild(downloadButton);
            actions.appendChild(moveButton);
            content.appendChild(actions);

            docElement.appendChild(content);

            return docElement;
        }

        function toggleDocumentSelection(element) {
            const documentId = element.dataset.documentId;
            const selectionBubble = element.querySelector('.selection-bubble');
            
            if (selectedDocuments.has(documentId)) {
                selectedDocuments.delete(documentId);
                element.classList.remove('selected');
                selectionBubble.classList.remove('selected');
                
                // Add ripple effect on deselection
                const ripple = document.createElement('div');
                ripple.className = 'ripple';
                element.appendChild(ripple);
                setTimeout(() => ripple.remove(), 600);
            } else {
                selectedDocuments.add(documentId);
                element.classList.add('selected');
                selectionBubble.classList.add('selected');
                
                // Add ripple effect on selection
                const ripple = document.createElement('div');
                ripple.className = 'ripple';
                element.appendChild(ripple);
                setTimeout(() => ripple.remove(), 600);
            }
            
            updateMoveButton();
        }

        function updateMoveButton() {
            const bulkActions = document.getElementById('bulkActions');
            const selectedCount = document.getElementById('selectedCount');
            
            if (selectedDocuments.size > 0) {
                bulkActions.classList.remove('hidden');
                selectedCount.textContent = `${selectedDocuments.size} items selected`;
                
                // Add animation to the count
                selectedCount.style.animation = 'none';
                selectedCount.offsetHeight; // Trigger reflow
                selectedCount.style.animation = 'fadeIn 0.3s ease-out';
            } else {
                bulkActions.classList.add('hidden');
            }
        }

        async function showDocumentDetails(doc) {
            try {
                console.log('Showing details for document:', doc);
                const modal = document.getElementById('documentModal');
                
                // Store current document for download
                currentDocument = doc;
                
                // Show the modal
                modal.classList.remove('hidden');
                
                // Force refresh document data from database to get latest metadata
                console.log('🔄 === FORCING DOCUMENT REFRESH FROM DATABASE ===');
                console.log('📄 Document ID:', doc.id);
                
                try {
                    // Use IPC to get fresh document data from main process
                    const freshDoc = await window.electron.ipcRenderer.invoke('get-document-details', doc.id);
                    
                    if (freshDoc && freshDoc.success) {
                        console.log('✅ Fresh document data received:', freshDoc.data);
                        
                        // Update the document object with fresh data
                        Object.assign(doc, freshDoc.data);
                        
                        // Update local cache
                        if (Array.isArray(window.lastDocuments)) {
                            const docIndex = window.lastDocuments.findIndex(d => d.id == doc.id);
                            if (docIndex !== -1) {
                                window.lastDocuments[docIndex] = freshDoc.data;
                                console.log('✅ Updated document in local cache');
                            }
                        }
                    } else {
                        console.warn('⚠️ Failed to fetch fresh document data, using cached data');
                    }
                } catch (error) {
                    console.warn('⚠️ Error fetching fresh document data:', error);
                }
                
                // Update modal content with document details (now with fresh data)
                document.getElementById('documentName').textContent = doc.name;
                document.getElementById('documentType').textContent = doc.type || 'PDF';
                document.getElementById('documentSize').textContent = formatFileSize(doc.size);
                document.getElementById('documentUploadDate').textContent = formatDate(doc.uploadDate);
                document.getElementById('documentComment').textContent = doc.comment || 'No comment available';
                
                // Handle keywords - try both new format (keywords array) and old format (mot1-mot5)
                const keywords = [];
                if (doc.keywords && Array.isArray(doc.keywords)) {
                    // New format: keywords array
                    keywords.push(...doc.keywords.filter(k => k && k.trim()));
                } else {
                    // Old format: mot1-mot5 fields
                    if (doc.mot1 && doc.mot1.trim()) keywords.push(doc.mot1.trim());
                    if (doc.mot2 && doc.mot2.trim()) keywords.push(doc.mot2.trim());
                    if (doc.mot3 && doc.mot3.trim()) keywords.push(doc.mot3.trim());
                    if (doc.mot4 && doc.mot4.trim()) keywords.push(doc.mot4.trim());
                    if (doc.mot5 && doc.mot5.trim()) keywords.push(doc.mot5.trim());
                }
                
                const keywordsElement = document.getElementById('documentKeywords');
                if (keywords.length > 0) {
                    keywordsElement.textContent = keywords.join(', ');
                } else {
                    keywordsElement.textContent = 'No keywords';
                }
                
                // Handle tags from tags array
                const tagsElement = document.getElementById('documentTags');
                if (doc.tags && Array.isArray(doc.tags) && doc.tags.length > 0) {
                    const tagNames = doc.tags.map(tag => tag.tag_name || tag).filter(name => name && name.trim());
                    if (tagNames.length > 0) {
                        tagsElement.textContent = tagNames.join(', ');
                    } else {
                        tagsElement.textContent = 'No tags';
                    }
                } else {
                    tagsElement.textContent = 'No tags';
                }

                // Request document path
                console.log('Requesting document path for:', doc.path);
                const filePath = await window.electron.ipcRenderer.invoke('get-document-path', doc.path, doc.name);
                
                if (!filePath) {
                    console.log('Could not get document path');
                    document.getElementById('pdfViewer').classList.add('hidden');
                    document.getElementById('pdfError').classList.remove('hidden');
                    document.getElementById('pdfError').textContent = 'Could not find the document file';
                    return;
                }

                // Load and render PDF
                const loadingTask = pdfjsLib.getDocument(filePath);
                const pdf = await loadingTask.promise;

                const pagesContainer = document.getElementById('pdfPages');
                pagesContainer.innerHTML = '';

                const containerWidth = document.getElementById('pdfViewer').clientWidth;

                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const baseViewport = page.getViewport({ scale: 1.5 });
                    const scale = Math.min(2.0, containerWidth / baseViewport.width);
                    const viewport = page.getViewport({ scale });

                    const canvas = document.createElement('canvas');
                    canvas.className = 'w-full bg-white rounded shadow';
                    canvas.width = viewport.width;
                    canvas.height = viewport.height;
                    const context = canvas.getContext('2d');

                    await page.render({ canvasContext: context, viewport }).promise;
                    pagesContainer.appendChild(canvas);
                }

                document.getElementById('pdfViewer').classList.remove('hidden');
                document.getElementById('pdfError').classList.add('hidden');

            } catch (error) {
                console.error('Error showing document details:', error);
                document.getElementById('pdfViewer').classList.add('hidden');
                document.getElementById('pdfError').classList.remove('hidden');
                document.getElementById('pdfError').textContent = 'Error loading document: ' + error.message;
            }
        }

        async function viewCurrentDocument(documentName) {
            try {
                await window.electron.ipcRenderer.invoke('view-document', documentName);
            } catch (error) {
                console.error('Error viewing document:', error);
                alert('Error viewing document: ' + error.message);
            }
        }

        async function downloadCurrentDocument() {
            try {
                if (!currentDocument) {
                    throw new Error('No document selected');
                }

                const response = await window.electron.ipcRenderer.invoke('download-document', {
                    path: currentDocument.path,
                    name: currentDocument.name
                });

                if (!response) {
                    throw new Error('Failed to download document');
                }

                // Create a temporary link element
                const a = document.createElement('a');
                a.href = response;
                a.download = currentDocument.name;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(response);

            } catch (error) {
                console.error('Error downloading document:', error);
                alert('Error downloading document: ' + error.message);
            }
        }

        function closeModal() {
            const modal = document.getElementById('documentModal');
            const pdfViewer = document.getElementById('pdfViewer');
            const pdfError = document.getElementById('pdfError');
            
            if (modal) modal.classList.add('hidden');
            if (pdfViewer) pdfViewer.classList.add('hidden');
            if (pdfError) pdfError.classList.add('hidden');
        }

        // Handle folder structure updates
        ipcRenderer.on('folder-structure', (event, data) => {
            console.log('\n=== FOLDER STRUCTURE UPDATE ===');
            console.log('Current path:', data.currentPath);
            console.log('Previous path:', window.currentFolderPath);
            console.log('Is processing move:', window.isProcessingMove);
            
            // Skip folder structure updates if move dialog is open
            if (isMoveDialogOpen) {
                console.log('DEBUG: Skipping folder structure update - move dialog is open');
                return;
            }
            
            const folderList = document.getElementById('folderTree');
            const documentsGrid = document.getElementById('documentsGrid');
            
            if (!folderList || !documentsGrid) {
                console.error('DEBUG: Required DOM elements not found');
                return;
            }
            
            // During move operations, only allow updates for specific folders
            if (window.isProcessingMove) {
                const allowedPaths = [
                    window.currentFolderPath,
                    window.lastSourcePath,
                    window.lastTargetPath
                ].filter(Boolean);
                
                console.log('Allowed paths during move:', allowedPaths);
                
                if (data.currentPath === '' || !allowedPaths.includes(data.currentPath)) {
                    console.log('Preventing unauthorized path change during move. Keeping:', window.currentFolderPath);
                    data.currentPath = window.currentFolderPath;
                }
            }
            
            // Never allow empty path during file operations
            if (data.currentPath === '' && window.currentFolderPath) {
                console.log('Preventing root redirect, keeping path:', window.currentFolderPath);
                data.currentPath = window.currentFolderPath;
            }
            
            // Update current folder path only if it's not empty and allowed
            if (data.currentPath) {
                window.currentFolderPath = data.currentPath;
                console.log('Updated folder path to:', window.currentFolderPath);
            }
            
            // Use displayFolders function for consistent UI updates
            console.log('🎨 Calling displayFolders from folder-structure listener');
            window.displayFolders(data);
        });

        // Listen for WebSocket events from main process
        ipcRenderer.on('socket-event', (event, data) => {
            console.log('\n=== DEBUG: Received socket event in renderer ===');
            console.log('DEBUG: Event:', data.event);
            console.log('DEBUG: Data:', JSON.stringify(data.data, null, 2));

            // Removed duplicate refresh_folder handler - using IPC handler instead
        });

        // Listen specifically for refresh-folder events
        ipcRenderer.on('refresh-folder', (event, data) => {
            console.log('\n=== DEBUG: Received refresh-folder event in renderer ===');
            console.log('DEBUG: Event data:', JSON.stringify(data, null, 2));
            handleRefreshFolder(data);
        });

        function handleRefreshFolder(data) {
            console.log('\n🔄 === SMART FOLDER REFRESH ===');
            console.log('📦 Event data:', JSON.stringify(data, null, 2));
            
            if (!data || !data.folderPath) {
                console.error('❌ Invalid refresh_folder data:', data);
                return;
            }

            // Get current path - prefer window.currentFolderPath if available
            let currentPath = '';
            
            if (window.currentFolderPath) {
                currentPath = window.currentFolderPath;
                console.log('🎯 Using window.currentFolderPath:', currentPath);
            } else {
                // Fallback to breadcrumb analysis
                const locationPath = document.getElementById('location-path');
                
                if (locationPath) {
                    // Build current path from breadcrumb items
                    const pathItems = Array.from(locationPath.children)
                        .filter(item => item.tagName === 'SPAN' && item.classList.contains('location-folder'))
                        .map(item => item.textContent.trim());
                        
                    if (pathItems.length > 0) {
                        currentPath = pathItems.join('/');
                    }
                }
                console.log('🔄 Using breadcrumb path:', currentPath);
            }
            
            console.log('📍 Current path in Electron:', currentPath);
            console.log('🎯 Target folder from event:', data.folderPath);
            
            // Clean both paths for comparison
            const cleanCurrentPath = currentPath.replace(/^\/+|\/+$/g, '');
            const cleanTargetPath = data.folderPath.replace(/^\/+|\/+$/g, '');
            
            // Detect if this is a move event
            const isMoveEvent = data.eventType && (data.eventType === 'move_source' || data.eventType === 'move_target');
            
            console.log('🧹 Cleaned paths:', {
                current: cleanCurrentPath,
                target: cleanTargetPath
            });
            console.log('🔍 Event type:', data.eventType || 'unknown');
            console.log('🔍 Is move event:', isMoveEvent);

            // Only refresh if we're in the exact target folder and not processing a move
            if (cleanCurrentPath === cleanTargetPath && !window.isProcessingMove) {
                console.log('✅ EXACT MATCH! Force fetching FRESH data from backend');
                
                // Add delay for move operations to ensure backend UPDATE is complete
                setTimeout(() => {
                    console.log('📤 Sending get-folder-structure for current folder');
                window.electron.ipcRenderer.send('get-folder-structure', {
                        institutionId: window.userData?.institution_id,
                        currentPath: cleanCurrentPath
                    });
                }, 1000); // 1 second delay for database UPDATE to complete
                
                // Show appropriate notification only if not processing a move
                if (!window.isProcessingMove) {
                    const messageType = isMoveEvent ? 'Document Moved' : 'Document Added';
                    const messageName = data.documentName || 'Document';
                    
                    showToast({
                        title: messageType,
                        message: `${messageName} was ${isMoveEvent ? 'moved' : 'added'} successfully`,
                        type: 'success',
                        duration: 3000
                    });
                }
            } else {
                console.log('ℹ️ Different folders - no refresh needed');
                console.log(`   Current: "${cleanCurrentPath}"`);
                console.log(`   Target:  "${cleanTargetPath}"`);
            }
        }

        // Add event listeners for document actions
        ipcRenderer.on('document-viewed', (event, success) => {
            if (!success) {
                alert('Failed to open document. Please try again.');
            }
        });

        ipcRenderer.on('document-downloaded', (event, success) => {
            if (success) {
                alert('Document downloaded successfully!');
            } else {
                alert('Failed to download document. Please try again.');
            }
        });

        // Add WebSocket status monitoring
        ipcRenderer.on('ws-status', (event, status) => {
            console.log('=== WebSocket Status Update ===');
            console.log('Status:', status);
            
            if (status === 'connected') {
                console.log('WebSocket connected successfully');
                // Request initial folder structure
                if (window.userData) {
                    console.log('Requesting initial folder structure');
                    window.electron.ipcRenderer.send('get-folder-structure', {
                        institutionId: window.userData.institution_id,
                        currentPath: document.querySelector('.breadcrumb').textContent.trim()
                    });
                }
            } else if (status === 'disconnected') {
                console.log('WebSocket disconnected');
            }
        });

        ipcRenderer.on('ws-error', (event, error) => {
            console.error('=== WebSocket Error ===');
            console.error('Error details:', error);
        });

        // Add new event listeners for sync functionality (guard missing elements)
        const addSyncFolderBtn = document.getElementById('addSyncFolder');
        if (addSyncFolderBtn) {
            addSyncFolderBtn.addEventListener('click', () => {
                window.electron.ipcRenderer.send('select-folder');
            });
        }

        // Add test button for folder creation
        const testCreateFolderBtn = document.getElementById('testCreateFolder');
        if (testCreateFolderBtn) testCreateFolderBtn.addEventListener('click', async () => {
            console.log('🧪 Testing folder creation...');
            try {
                // First check if institution folder exists
                const folderCheck = await window.electron.ipcRenderer.invoke('check-institution-folder');
                console.log('Folder check result:', folderCheck);
                
                // Force creation dialog by calling create-institution-folder directly
                const result = await window.electron.ipcRenderer.invoke('create-institution-folder');
                console.log('Creation result:', result);
                
                if (result.success) {
                    showNotification('Test successful! Folder created/checked.', 'success');
                } else {
                    showNotification(`Test failed: ${result.message}`, 'error');
                }
            } catch (error) {
                console.error('Test error:', error);
                showNotification(`Test error: ${error.message}`, 'error');
            }
        });

        // Add sync documents button
        const syncDocumentsBtn = document.getElementById('syncDocuments');
        if (syncDocumentsBtn) syncDocumentsBtn.addEventListener('click', async () => {
            console.log('🔄 Manual document sync started...');
            
            // Show loading state
            const syncButton = document.getElementById('syncDocuments');
            const originalText = syncButton.innerHTML;
            syncButton.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Sincronizare...';
            syncButton.disabled = true;
            
            try {
                const result = await window.electron.ipcRenderer.invoke('sync-documents');
                console.log('Sync result:', result);
                
                if (result.success) {
                    showNotification('Documentele au fost sincronizate cu succes!', 'success');
                    // Refresh the current folder view
                    refreshFolderStructure();
                } else {
                    showNotification(`Eroare sincronizare: ${result.message}`, 'error');
                }
            } catch (error) {
                console.error('Sync error:', error);
                showNotification(`Eroare sincronizare: ${error.message}`, 'error');
            } finally {
                // Restore button state
                syncButton.innerHTML = originalText;
                syncButton.disabled = false;
            }
        });

        // Add test folders button
        const testFoldersBtn = document.getElementById('testFolders');
        if (testFoldersBtn) {
            testFoldersBtn.addEventListener('click', async () => {
            console.log('🧪 Testing folders API...');
            try {
                const result = await require('electron').ipcRenderer.invoke('test-load-folders');
                console.log('🧪 Folders test result:', result);
                
                if (result.success) {
                    console.log(`✅ Found ${result.filtered} folders for user (${result.total} total)`);
                    console.log('📁 Sample folders:', result.folders.slice(0, 5));
                } else {
                    console.error('❌ Folders test failed:', result.message);
                    if (result.details) console.error('Details:', result.details);
                }
            } catch (error) {
                console.error('🧪 Folders test error:', error);
            }
            });
        }

        // Add test documents button
        const testDocumentsBtn = document.getElementById('testDocuments');
        if (testDocumentsBtn) {
            testDocumentsBtn.addEventListener('click', async () => {
            console.log('🧪 Testing documents API...');
            try {
                const result = await require('electron').ipcRenderer.invoke('test-load-documents');
                console.log('🧪 Documents test result:', result);
                
                if (result.success) {
                    console.log(`✅ Found ${result.filtered} documents for user (${result.total} total)`);
                    console.log('📄 Sample documents:', result.documents.slice(0, 5));
                } else {
                    console.error('❌ Documents test failed:', result.message);
                    if (result.details) console.error('Details:', result.details);
                }
            } catch (error) {
                console.error('🧪 Documents test error:', error);
            }
            });
        }

        // Handle folder selection response
        ipcRenderer.on('folder-selected', (event, data) => {
            console.log('Folder selected for sync:', data);
            
            // Add the folder to the synced folders list
            const syncedFolders = document.getElementById('synced-folders');
            const folderElement = document.createElement('div');
            folderElement.className = 'flex items-center justify-between p-2 bg-gray-50 rounded mb-2';
            folderElement.innerHTML = `
                <div class="flex items-center">
                    <i class="fas fa-folder text-yellow-500 mr-2"></i>
                    <span class="text-sm text-gray-700">${path.basename(data.path)}</span>
                </div>
                <div class="flex items-center">
                    <span class="text-xs text-green-500 mr-2">${data.status}</span>
                    <button class="text-red-500 hover:text-red-600" onclick="removeSyncedFolder('${data.path}')">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            `;
            syncedFolders.appendChild(folderElement);
            
            // Update sync status with folder selection data
            updateSyncStatus({
                type: 'add',
                sourcePath: data.path
            });
        });

        // Removed duplicate sync-error handler - keeping only the one below

        // Handle file added event
        ipcRenderer.on('file-added', (event, data) => {
            console.log('File added:', data);
            
            // Get current path from breadcrumb
            const currentPathElement = document.getElementById('currentPath');
            const currentPath = currentPathElement ? currentPathElement.textContent.trim() : '';
            console.log('Current path:', currentPath);
            
            // Get the folder path from the data
            const folderPath = data.folder || '';
            console.log('Folder path from data:', folderPath);
            
            // If we're in the same folder where the file was added, refresh the folder structure
            if (currentPath.includes(folderPath)) {
                console.log('Refreshing current folder structure');
                window.electron.ipcRenderer.send('get-folder-structure', {
                    institutionId: window.userData.institution_id,
                    currentPath: currentPath
                });
            }
            
            // Update sync status
            const syncStatus = document.getElementById('sync-status-text');
            syncStatus.textContent = `Synced: ${path.basename(data.path)}`;
            syncStatus.className = 'text-sm text-green-500';
            
            // Reset status after 3 seconds
            setTimeout(() => {
                syncStatus.textContent = 'Syncing...';
                syncStatus.className = 'text-sm text-gray-500';
            }, 3000);
        });

        // Handle file deleted event
        ipcRenderer.on('file-deleted', (event, data) => {
            console.log('File deleted:', data);
            // Remove file from UI
            const fileList = document.getElementById('file-list');
            if (fileList) {
                const fileElements = fileList.getElementsByClassName('file-item');
                for (let element of fileElements) {
                    if (element.querySelector('.file-name').textContent === path.basename(data.path)) {
                        element.remove();
                        break;
                    }
                }
            }
            
            // Update sync status
            const syncStatus = document.getElementById('sync-status-text');
            syncStatus.textContent = `Deleted: ${path.basename(data.path)}`;
            syncStatus.className = 'text-sm text-yellow-500';
            
            // Reset status after 3 seconds
            setTimeout(() => {
                syncStatus.textContent = 'Syncing...';
                syncStatus.className = 'text-sm text-gray-500';
            }, 3000);
        });

        function updateSyncStatus(data) {
            const syncStatus = document.getElementById('sync-status-text');
            if (!syncStatus) return;

            let statusText = '';
            if (!data || !data.type) {
                statusText = 'Ready';
                syncStatus.className = 'text-sm text-gray-500';
            } else {
                switch (data.type) {
                    case 'add':
                        statusText = `Synced: ${path.basename(data.sourcePath)}`;
                        syncStatus.className = 'text-sm text-green-500';
                        break;
                    case 'remove':
                    case 'unlink':
                        statusText = `Deleted: ${path.basename(data.sourcePath)}`;
                        syncStatus.className = 'text-sm text-yellow-500';
                        break;
                    case 'change':
                        statusText = `Updated: ${path.basename(data.sourcePath)}`;
                        syncStatus.className = 'text-sm text-blue-500';
                        break;
                }
            }
            syncStatus.textContent = statusText;
            
            // Reset status after 3 seconds
            setTimeout(() => {
                syncStatus.textContent = 'Syncing...';
                syncStatus.className = 'text-sm text-gray-500';
            }, 3000);

            // Show notification if we have data
            if (data && data.type && data.sourcePath) {
                showNotification(`File ${data.type === 'add' ? 'added' : data.type === 'remove' ? 'deleted' : 'updated'}: ${path.basename(data.sourcePath)}`, 'success');
            }
        }

        function refreshFolderStructure() {
            // Skip refresh during move operations to prevent root redirect
            if (window.isProcessingMove) {
                console.log('🛡️ Skipping folder structure refresh during move operation');
                return;
            }
            
            // Try to get path from multiple sources in order of reliability
            let currentPath = '';
            
            // 1. Try window.currentFolderPath first (most reliable)
            if (window.currentFolderPath) {
                currentPath = window.currentFolderPath;
                console.log('Using window.currentFolderPath:', currentPath);
            }
            
            // 2. Try breadcrumb container data attribute
            if (!currentPath) {
                const breadcrumbContainer = document.querySelector('.breadcrumb-container');
                if (breadcrumbContainer) {
                    const breadcrumbPath = breadcrumbContainer.getAttribute('data-current-path');
                    if (breadcrumbPath) {
                        currentPath = breadcrumbPath;
                        console.log('Using breadcrumb container data:', currentPath);
                    }
                }
            }
            
            // 3. Try breadcrumb text content
            if (!currentPath) {
                const breadcrumb = document.querySelector('.breadcrumb');
                if (breadcrumb) {
                    const breadcrumbText = breadcrumb.textContent.trim();
                    if (breadcrumbText && breadcrumbText !== 'Root') {
                        const parts = breadcrumbText.split(' / ');
                        if (parts.length > 1) {
                            currentPath = parts.slice(1).join('/');
                            console.log('Using parsed breadcrumb text:', currentPath);
                        }
                    }
                }
            }
            
            // 4. Try active folder element
            if (!currentPath) {
                const activeFolder = document.querySelector('.folder-item.active, .folder-item[data-active="true"]');
                if (activeFolder && activeFolder.dataset.path) {
                    currentPath = activeFolder.dataset.path;
                    console.log('Using active folder path:', currentPath);
                }
            }
            
            // 5. Try current-folder class
            if (!currentPath) {
                const currentFolder = document.querySelector('.current-folder');
                if (currentFolder && currentFolder.dataset.path) {
                    currentPath = currentFolder.dataset.path;
                    console.log('Using current-folder path:', currentPath);
                }
            }
            
            // 6. Finally, try currentPath element (least reliable)
            if (!currentPath) {
            const currentPathElement = document.getElementById('currentPath');
                if (currentPathElement) {
                    const pathText = currentPathElement.textContent.trim();
                    if (pathText && pathText !== 'Root') {
                        currentPath = pathText;
                        console.log('Using currentPath element:', currentPath);
                    }
                }
            }
            
            // Normalize path
            const normalizedPath = currentPath.replace(/^Root\//, '').replace(/\/$/, '');
            
            // Don't refresh to root during file operations if we have a valid current path
            if (!normalizedPath && window.currentFolderPath) {
                console.log('🛡️ Preventing root refresh, keeping current path:', window.currentFolderPath);
                return;
            }
            
            console.log('Refreshing folder structure for path:', normalizedPath);
            
            // Request folder structure update
            window.electron.ipcRenderer.send('get-folder-structure', {
                institutionId: window.userData.institution_id,
                currentPath: normalizedPath || ''
            });
        }

        // Fixed drag and drop functions for the main drop zone
        function handleDropZoneDragOver(event) {
            event.preventDefault();
            event.stopPropagation();
            event.dataTransfer.dropEffect = 'copy';
            const dropZone = event.currentTarget;
            if (dropZone && dropZone.classList) {
                dropZone.classList.add('drag-over');
            }
        }

        function handleDropZoneDragEnter(event) {
            event.preventDefault();
            event.stopPropagation();
            const dropZone = event.currentTarget;
            if (dropZone && dropZone.classList) {
                dropZone.classList.add('drag-over');
            }
        }

        function handleDropZoneDragLeave(event) {
            event.preventDefault();
            event.stopPropagation();
            const dropZone = event.currentTarget;
            if (dropZone && dropZone.classList) {
                dropZone.classList.remove('drag-over');
            }
        }

        function handleDropZoneDrop(event) {
            event.preventDefault();
            event.stopPropagation();
            
            console.log('=== Drop event triggered ===');
            console.log('Event:', event);
            console.log('DataTransfer:', event.dataTransfer);
            
            const dropZone = event.currentTarget;
            if (dropZone && dropZone.classList) {
                dropZone.classList.remove('drag-over');
            }

            // Get files from the drop event
            const files = event.dataTransfer.files;
            console.log('Files dropped:', files.length);
            
            if (files && files.length > 0) {
                // Get current path - use window.currentFolderPath instead of DOM parsing
                let currentPath = '';
                if (window.currentFolderPath) {
                    currentPath = window.currentFolderPath;
                    console.log('🎯 Using window.currentFolderPath:', currentPath);
                } else {
                    // Fallback to breadcrumb parsing
            const currentPathElement = document.getElementById('currentPath');
                    currentPath = currentPathElement ? currentPathElement.textContent.trim() : '';
            
                // Clean up the path
            currentPath = currentPath.replace(/^Root\//, '').replace(/\/$/, '');
            
                // If we're in the root, use empty string as base path
                if (!currentPath || currentPath === 'Root') {
                    currentPath = '';
                    }
                    console.log('📋 Using fallback breadcrumb parsing:', currentPath);
                }

                console.log('✅ Final target path for upload:', currentPath);

                // Add files to staging area instead of processing instantly
                console.log('📋 Adding files to staging area...');
                
                // Set target path for upload
                window.uploadTargetPath = currentPath;
                
                // Process each dropped item
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    console.log('Adding file to staging:', file.name, 'path:', file.path);
                    
                    if (file.path) { // Check if it's an Electron file with path property
                        // Check if it's a directory (in Electron, directories have type '')
                        const fs = require('fs');
                        const path = require('path');
                        
                        try {
                            const stats = fs.statSync(file.path);
                            if (stats.isDirectory()) {
                                // Check current tab - prevent folder drops in PDF tab
                                if (window.currentUploadTab === 'files') {
                                    console.log('📁 Folder dropped in PDF tab - preventing');
                                    showToast({ title: 'Folder invalid', message: 'Folosește tabul "Foldere" pentru a încărca foldere.', type: 'warning', duration: 2500 });
                                    continue;
                                }
                                
                                console.log('📁 Staging directory (no instant upload):', file.path, 'to target:', currentPath);
                                // Stage folder for later upload
                                if (!Array.isArray(window.selectedFolders)) window.selectedFolders = [];
                                const folderName = path.basename(file.path);
                                if (!window.selectedFolders.some(f => f && f.path === file.path)) {
                                    window.selectedFolders.push({ path: file.path, name: folderName });
                                    showToast({ title: 'Folder added', message: `${folderName} added to staging`, type: 'success', duration: 2000 });
                                } else {
                                    console.log('⚠️ Folder already in staging:', folderName);
                                }
                                // Refresh preview list
                                if (typeof window.updateSelectedFoldersPreview === 'function') {
                                    window.updateSelectedFoldersPreview();
                                }
                            } else if (file.name.toLowerCase().endsWith('.pdf')) {
                                // Check current tab - prevent PDF drops in folder tab
                                if (window.currentUploadTab === 'folders') {
                                    console.log('📄 PDF dropped in Folder tab - preventing');
                                    showToast({ title: 'PDF invalid', message: 'Folosește tabul "PDF-uri" pentru a încărca PDF-uri.', type: 'warning', duration: 2500 });
                                    continue;
                                }
                                
                                console.log('📄 Adding PDF file to staging:', file.path);
                                // Add PDF file to staging area
                                if (!window.selectedFiles.includes(file.path)) {
                                    window.selectedFiles.push(file.path);
                                    console.log('✅ Added to staging:', file.name);
                                } else {
                                    console.log('⚠️ File already in staging:', file.name);
                                }
                            } else {
                                console.log('Skipping non-PDF file:', file.name);
                                showToast({
                                    title: 'File Skipped',
                                    message: `${file.name} - Only PDF files and folders are supported`,
                                    type: 'warning',
                                    duration: 3000
                                });
                            }
                        } catch (error) {
                            console.error('Error processing file:', error);
                            showToast({
                                title: 'Error',
                                message: `Error processing ${file.name}: ${error.message}`,
                                type: 'error',
                                duration: 4000
                            });
                        }
                    }
                }
                
                // Update staging area preview
                window.updateSelectedFilesPreview();
                
                // Show success notification
                if (window.selectedFiles.length > 0) {
                    showToast({
                        title: 'Files Added',
                        message: `${files.length} file(s) added to staging area`,
                        type: 'success',
                        duration: 2000
                    });
                }
            } else {
                console.log('No files in drop event');
            }
        }

        // Add handler for file processing response
        ipcRenderer.on('file-processed', (event, response) => {
            console.log('File processing response:', response);
            if (response.success) {
                showToast({
                    title: 'Success',
                    message: `File "${response.fileName}" processed successfully`,
                    type: 'success',
                    duration: 3000
                });
                // Instant refresh without wait
                try { loadFolderContents(); } catch {}
            } else {
                showToast({
                    title: 'Error',
                    message: `Failed to process file: ${response.error}`,
                    type: 'error',
                    duration: 4000
                });
            }
        });

        // Add handler for folder processing response (from add-folder event)
        ipcRenderer.on('folder-added', (event, response) => {
            console.log('🎉 [FOLDER-ADDED] Received folder-added event:', response);
            console.log('🎉 [FOLDER-ADDED] Response name:', response.name);
            console.log('🎉 [FOLDER-ADDED] Response path:', response.path);
            console.log('🎉 [FOLDER-ADDED] Response institution:', response.institution);
            
            // Show success notification
            showToast({
                title: 'Folder Uploaded',
                message: `Folder "${response.name}" uploaded successfully`,
                type: 'success',
                duration: 2000
            });

            // Navigate to the newly created folder
            setTimeout(async () => {
                console.log('🔄 [NAV] Starting navigation to newly created folder:', response.path);
                console.log('🔄 [NAV] Response details:', response);
                
                try {
                    // Create folder object for navigation
                    const newFolder = {
                        folder_name: response.name,
                        folder_path: response.path,
                        institution_name: response.institution
                    };
                    
                    console.log('🔄 [NAV] Created folder object:', newFolder);
                    
                    // Update current state
                    console.log('🔄 [NAV] Updating current state...');
                    currentPath = response.path;
                    window.currentFolderPath = response.path;
                    currentFolder = newFolder;
                    
                    console.log('🔄 [NAV] State updated - currentPath:', currentPath);
                    console.log('🔄 [NAV] State updated - window.currentFolderPath:', window.currentFolderPath);
                    
                    // Navigate to the new folder using existing function
                    console.log('📁 [NAV] Loading contents of new folder:', newFolder);
                    await loadFolderContents(newFolder);
                    
                    console.log('✅ [NAV] Successfully navigated to new folder');
                    
                } catch (error) {
                    console.error('❌ [NAV] Error navigating to new folder:', error);
                    console.error('❌ [NAV] Error stack:', error.stack);
                    // Fallback: just refresh the current view
                    console.log('🔄 [NAV] Fallback: refreshing current view');
                    loadFolderContents();
                }
            }, 2000);
        });

        // Add handler for sync errors (deduplicated)
        ipcRenderer.on('sync-error', (event, error) => {
            console.error('Sync error:', error);
            
            // Don't show modal if a success toast was shown recently (within 2 seconds)
            const now = Date.now();
            if (window.__lastSuccessToastTime && (now - window.__lastSuccessToastTime) < 2000) {
                console.log('🚫 Skipping error modal - success toast was shown recently');
                return;
            }
            
            if (!window.__syncErrorModalShown) {
                window.__syncErrorModalShown = true;
                showProtectedModal(typeof error === 'string' ? error : 'Operatiune nepermisa');
            }
        });

        // Add handler for folder move success
        ipcRenderer.on('folder-move-success', (event, data) => {
            console.log('✅ Folder move success:', data);
            showSuccessToast(data.message);
        });

        // Add handler for force sidebar refresh
        ipcRenderer.on('force-sidebar-refresh', (event, data) => {
            console.log('🔄 Force sidebar refresh requested:', data);
            // Force refresh the folder structure in sidebar
            setTimeout(() => {
                console.log('🔄 Executing forced sidebar refresh');
                window.electron.ipcRenderer.send('get-folder-structure', {
                    institutionId: window.userData?.institution_id,
                    currentPath: window.currentFolderPath || ''
                });
            }, 500); // Small delay to ensure move is complete
        });

        // Function to show elegant success toast
        function showSuccessToast(message) {
            // Record timestamp to prevent error modal conflicts
            window.__lastSuccessToastTime = Date.now();
            
            // Reset modal flag to allow future error modals for actual errors
            window.__syncErrorModalShown = false;
            
            // Remove any existing success toasts
            const existingToasts = document.querySelectorAll('.success-toast');
            existingToasts.forEach(toast => toast.remove());

            // Create elegant toast element
            const toast = document.createElement('div');
            toast.className = 'success-toast fixed top-6 right-6 bg-slate-800/95 backdrop-blur-sm text-slate-100 px-5 py-4 rounded-xl shadow-2xl border border-slate-700/50 z-50 flex items-center space-x-3 max-w-sm';
            toast.innerHTML = `
                <div class="flex-shrink-0 w-8 h-8 bg-emerald-500/20 rounded-full flex items-center justify-center">
                    <i class="fas fa-check text-emerald-400 text-sm"></i>
                </div>
                <div class="flex-1 min-w-0">
                    <div class="text-sm font-medium text-slate-100 truncate">${message}</div>
                </div>
                <button onclick="this.parentElement.remove()" class="flex-shrink-0 text-slate-400 hover:text-slate-200 transition-colors p-1">
                    <i class="fas fa-times text-xs"></i>
                </button>
            `;

            // Add to body
            document.body.appendChild(toast);

            // Auto-remove after 4 seconds
            setTimeout(() => {
                if (toast.parentElement) {
                    toast.style.transition = 'all 0.3s ease-out';
                    toast.style.transform = 'translateX(100%)';
                    toast.style.opacity = '0';
                    setTimeout(() => toast.remove(), 300);
                }
            }, 4000);

            // Add elegant slide-in animation
            toast.style.transform = 'translateX(100%)';
            toast.style.opacity = '0';
            setTimeout(() => {
                toast.style.transition = 'all 0.4s cubic-bezier(0.16, 1, 0.3, 1)';
                toast.style.transform = 'translateX(0)';
                toast.style.opacity = '1';
            }, 50);
        }

        // Already declared earlier; just ensure default value
        isMoveDialogOpen = false;

        function showMoveDialog(items) {
            isMoveDialogOpen = true;
            moveDialogSelectedItems = items;
            const dialog = document.getElementById('moveDialog');
            const selectedItemsContainer = document.getElementById('moveDialogSelectedItems');
            
            // Store the current path before opening dialog
            window.lastMoveSourcePath = document.getElementById('location-path').textContent.trim();
            
            // Clear and populate selected items
            selectedItemsContainer.innerHTML = '';
            items.forEach(item => {
                const itemElement = document.createElement('div');
                itemElement.className = 'flex items-center p-3 bg-white rounded-lg border border-gray-200 mb-2';
                itemElement.innerHTML = `
                    <i class="fas ${item.type === 'folder' ? 'fa-folder text-yellow-500' : 'fa-file text-blue-500'} mr-3 text-lg"></i>
                    <div class="flex flex-col">
                        <span class="text-gray-800 font-medium">${item.name}</span>
                        <span class="text-sm text-gray-500">${item.path}</span>
                    </div>
                `;
                selectedItemsContainer.appendChild(itemElement);
            });

            // Initialize folder navigation
            navigateToRootInMoveDialog();
            
            // Show dialog
            dialog.classList.remove('hidden');
        }

        // Funcție pentru popularea selectului cu foldere
        async function populateFolderSelect(select) {
            try {
                const userInfo = await require('electron').ipcRenderer.invoke('get-user-info');
                if (!userInfo) return;

                const response = await window.electron.ipcRenderer.invoke('get-folder-structure', {
                    institutionId: userInfo.institution_id
                });

                select.innerHTML = '<option value="">Select a folder...</option>';
                
                if (response && response.folders) {
                    response.folders.forEach(folder => {
                        const option = document.createElement('option');
                        option.value = folder.path;
                        option.textContent = folder.name;
                        select.appendChild(option);
                    });
                }
            } catch (error) {
                console.error('Error populating folder select:', error);
            }
        }

        // Funcție pentru mutarea elementelor
        async function moveItems(items, destinationFolder) {
            try {
                const userInfo = await require('electron').ipcRenderer.invoke('get-user-info');
                if (!userInfo) return;

                for (const item of items) {
                    const moveData = {
                        type: item.type === 'folder' ? 'move_folder' : 'move',
                        sourcePath: item.path || item.sourcePath,
                        targetFolder: destinationFolder,
                        documentId: item.id,
                        institutionId: userInfo.institution_id
                    };

                    window.electron.ipcRenderer.send('fileSystemChange', moveData);
                }

                showNotification('Success', `${items.length} items moved successfully`);
                
                // Resetare selecții
                document.querySelectorAll('.document-checkbox, .folder-checkbox').forEach(checkbox => {
                    checkbox.checked = false;
                });
                document.getElementById('bulkActions').classList.add('hidden');
                
            } catch (error) {
                console.error('Error moving items:', error);
                showNotification('Error', 'Failed to move items');
            }
        }

        // Event listeners pentru drag and drop
        function handleDragStart(e) {
            e.dataTransfer.setData('text/plain', JSON.stringify({
                type: this.classList.contains('folder-item') ? 'folder' : 'document',
                id: this.dataset.documentId || this.dataset.folderPath,
                name: this.querySelector('.folder-name, .document-name').textContent
            }));
            this.classList.add('opacity-50');
        }

        function handleDragEnd(e) {
            this.classList.remove('opacity-50');
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            this.classList.add('bg-blue-100');
        }

        function handleDrop(e) {
            e.preventDefault();
            this.classList.remove('bg-blue-100');
            
            try {
                const data = JSON.parse(e.dataTransfer.getData('text/plain'));
                const targetFolder = this.dataset.folderPath;
                
                showMoveDialog([{
                    type: data.type,
                    id: data.id,
                    name: data.name
                }]);
            } catch (error) {
                console.error('Error handling drop:', error);
                showNotification('Error', 'Failed to move item');
            }
        }

        // Event listener pentru butonul de mutare în bulk (check if exists)
        const bulkMoveBtn = document.getElementById('bulkMoveBtn');
        if (bulkMoveBtn) {
            bulkMoveBtn.addEventListener('click', () => {
            const selectedDocs = Array.from(document.querySelectorAll('.document-checkbox:checked'))
                .map(checkbox => ({
                    type: 'document',
                    id: checkbox.dataset.documentId,
                    name: checkbox.closest('.document-item').querySelector('.document-name').textContent
                }));
            
            const selectedFolders = Array.from(document.querySelectorAll('.folder-checkbox:checked'))
                .map(checkbox => ({
                    type: 'folder',
                    path: checkbox.dataset.folderPath,
                    name: checkbox.closest('.folder-item').querySelector('.folder-name').textContent
                }));
            
            const selectedItems = [...selectedDocs, ...selectedFolders];
            if (selectedItems.length > 0) {
                showMoveDialog(selectedItems);
            }
        });
        }

        let moveDialogCurrentPath = '';
        let moveDialogSelectedItems = [];

        function navigateToRootInMoveDialog() {
            moveDialogCurrentPath = '';
            updateMoveDialogBreadcrumb();
            loadFoldersForMoveDialog();
        }

        function updateMoveDialogBreadcrumb() {
            const breadcrumb = document.getElementById('moveDialogBreadcrumb');
            // Keep only the Root button
            while (breadcrumb.children.length > 1) {
                breadcrumb.removeChild(breadcrumb.lastChild);
            }

            if (moveDialogCurrentPath) {
                const pathParts = moveDialogCurrentPath.split('/').filter(Boolean);
                let builtPath = '';
                
                pathParts.forEach((part, index) => {
                    builtPath += '/' + part;
                    
                    // Add separator
                    const separator = document.createElement('span');
                    separator.className = 'text-gray-400 mx-2';
                    separator.innerHTML = '<i class="fas fa-chevron-right"></i>';
                    breadcrumb.appendChild(separator);
                    
                    // Add path part
                    const folder = document.createElement('button');
                    folder.className = 'text-blue-600 hover:text-blue-700 font-medium';
                    folder.textContent = part;
                    folder.onclick = () => navigateToFolderInMoveDialog(builtPath);
                    breadcrumb.appendChild(folder);
                });
            }
        }

        async function loadFoldersForMoveDialog() {
            const foldersContainer = document.getElementById('moveDialogFolders');
            if (!foldersContainer) {
                console.error('Folders container not found');
                return;
            }

            try {
                console.log('Loading folders for move dialog...');
                foldersContainer.innerHTML = '<div class="text-center text-gray-500 py-4"><i class="fas fa-spinner fa-spin text-2xl mb-2"></i><p>Loading folders...</p></div>';

                // Use invoke to get folders directly for move dialog
                const response = await window.electron.ipcRenderer.invoke('get-folder-structure', {
                    institutionId: window.userData.institution_id,
                    currentPath: moveDialogCurrentPath
                });

                console.log('Move dialog folder response:', response);
                handleFolderStructureResponse(response);

            } catch (error) {
                console.error('Error loading folders for move dialog:', error);
                foldersContainer.innerHTML = `
                    <div class="text-center text-red-500 py-4">
                        <i class="fas fa-exclamation-circle text-2xl mb-2"></i>
                        <p>Error loading folders</p>
                    </div>
                `;
                showNotification('Error loading folders', 'error');
            }
        }

        // Add this function to handle folder structure updates
        function handleFolderStructureResponse(response) {
            console.log('Handling folder structure response:', response);
            const foldersContainer = document.getElementById('moveDialogFolders');
            if (!foldersContainer) return;

            foldersContainer.innerHTML = '';

            if (response && response.folders && response.folders.length > 0) {
                response.folders.forEach(folder => {
                    const folderElement = document.createElement('div');
                    folderElement.className = 'flex items-center p-3 bg-gray-50 rounded-lg border border-gray-200 cursor-pointer hover:bg-blue-50 hover:border-blue-200 transition-colors duration-200';
                    folderElement.innerHTML = `
                        <i class="fas fa-folder text-blue-500 mr-3 text-lg"></i>
                        <span class="text-gray-800 font-medium">${folder.name}</span>
                    `;
                    folderElement.onclick = () => navigateToFolderInMoveDialog(folder.path);
                    foldersContainer.appendChild(folderElement);
                });
            } else {
                foldersContainer.innerHTML = `
                    <div class="text-center text-gray-500 py-4">
                        <i class="fas fa-folder-open text-2xl mb-2"></i>
                        <p>No folders available</p>
                    </div>
                `;
            }
        }

        // Removed duplicate folder-structure-response handler to avoid conflicts

        function navigateToFolderInMoveDialog(path) {
            console.log('Navigating to folder:', path);
            moveDialogCurrentPath = path;
            updateMoveDialogBreadcrumb();
            loadFoldersForMoveDialog();
        }

        // Update event listeners for move dialog
        document.getElementById('closeMoveDialog').onclick = () => {
            document.getElementById('moveDialog').classList.add('hidden');
            isMoveDialogOpen = false;
        };

        document.getElementById('cancelMove').onclick = () => {
            document.getElementById('moveDialog').classList.add('hidden');
            isMoveDialogOpen = false;
        };

        // Update the confirmMove click handler
        document.getElementById('confirmMove').onclick = async () => {
            try {
                // Store the current path before moving
                const sourcePath = moveDialogSelectedItems[0].path;
                const destinationPath = moveDialogCurrentPath;
                
                // Get current path and clean it
                const locationPath = document.getElementById('location-path');
                let currentPath = '';
                
                // Build path from breadcrumb items
                const pathItems = Array.from(locationPath.children)
                    .filter(item => item.tagName === 'SPAN' && item.classList.contains('location-folder'))
                    .map(item => item.textContent.trim());
                    
                if (pathItems.length > 0) {
                    currentPath = pathItems.join('/');
                }
                
                console.log('Current path for refresh:', currentPath);
                console.log('Source path:', sourcePath);
                console.log('Destination path:', destinationPath);

                // Send move request
                for (const item of moveDialogSelectedItems) {
                    if (item.type === 'folder') {
                        const moveFolderData = {
                            type: 'move_folder',
                            sourcePath: item.path,
                            targetFolder: moveDialogCurrentPath
                        };
                        console.log('Sending move_folder request:', moveFolderData);
                        window.electron.ipcRenderer.send('fileSystemChange', moveFolderData);
                    } else {
                        const moveData = {
                            type: 'move_document',
                            documentId: item.id,
                            documentName: item.name,
                            oldPath: item.path,
                            newPath: moveDialogCurrentPath,
                            institutionId: window.userData.institution_id,
                            institutionName: window.userData.institution_name,
                            sourcePath: item.path,
                            destinationPath: moveDialogCurrentPath
                        };
                        console.log('Sending move_document request:', moveData);
                        window.electron.ipcRenderer.send('move-document', moveData);
                    }
                }

                // Store paths for move operation
                window.lastSourcePath = sourcePath;
                window.lastTargetPath = destinationPath;
                window.isProcessingMove = true;

                // Clear selected items
                moveDialogSelectedItems = [];
                selectedDocuments.clear();
                document.getElementById('bulkActions').classList.add('hidden');

                // Close the move dialog
                const moveDialog = document.getElementById('moveDialog');
                if (moveDialog) {
                    moveDialog.classList.add('hidden');
                    isMoveDialogOpen = false;
                }

                // Store the current folder path so we can stay here
                const currentViewPath = window.currentFolderPath || sourcePath;
                console.log('Current view path for move:', currentViewPath);
                
                // First refresh source folder to show item removed
                console.log('Refreshing source folder:', sourcePath);
                window.electron.ipcRenderer.send('get-folder-structure', {
                    institutionId: window.userData.institution_id,
                    currentPath: sourcePath
                });

                // Then refresh destination folder
                setTimeout(() => {
                console.log('Refreshing destination folder:', destinationPath);
                window.electron.ipcRenderer.send('get-folder-structure', {
                    institutionId: window.userData.institution_id,
                    currentPath: destinationPath
                });
                }, 500);

                // Clear move state after all operations complete
                setTimeout(() => {
                    window.isProcessingMove = false;
                    window.lastSourcePath = null;
                    window.lastTargetPath = null;
                    
                    // Final refresh of current folder
                    console.log('Final refresh of current folder:', currentViewPath);
                    window.electron.ipcRenderer.send('get-folder-structure', {
                        institutionId: window.userData.institution_id,
                        currentPath: currentViewPath
                    });
                }, 2000);

            } catch (error) {
                console.error('Error moving items:', error);
                showToast({
                    title: 'Error',
                    message: 'Failed to initiate move operation',
                    type: 'error',
                    duration: 4000
                });
            }
        };

        // Update the move-document-response handler
        window.electron.ipcRenderer.on('move-document-response', async (event, response) => {
            console.log('Received move-document-response:', response);
            
            if (response.success) {
                // Get current path from breadcrumb
                const locationPath = document.getElementById('location-path');
                let currentPath = '';
                
                if (locationPath) {
                    const pathItems = Array.from(locationPath.children)
                        .filter(item => item.tagName === 'SPAN' && item.classList.contains('location-folder'))
                        .map(item => item.textContent.trim());
                        
                    if (pathItems.length > 0) {
                        currentPath = pathItems.join('/');
                    }
                }
                
                console.log('Current path for refresh:', currentPath);
                
                // Only refresh the current folder we're in
                if (!window.isProcessingMove) {
                        window.electron.ipcRenderer.send('get-folder-structure', {
                            institutionId: window.userData.institution_id,
                        currentPath: currentPath || ''
                        });
                }

                // Clear any selected items
                selectedDocuments.clear();
                document.getElementById('bulkActions').classList.add('hidden');
            } else {
                showToast({
                    title: 'Error',
                    message: `Failed to move document: ${response.error || 'Unknown error'}`,
                    type: 'error',
                    duration: 4000
                });
            }
        });

        function refreshCurrentFolder() {
            console.log('\n🔄 === DASHBOARD: refreshCurrentFolder called ===');
            
            // Get current path - prefer window.currentFolderPath if available
            let currentPath = '';
            
            if (window.currentFolderPath) {
                currentPath = window.currentFolderPath;
                console.log('🔄 Using window.currentFolderPath:', currentPath);
            } else {
                // Try to get path from breadcrumb location
                const locationPath = document.getElementById('location-path');
                if (locationPath) {
                    // Build current path from breadcrumb items
                    const pathItems = Array.from(locationPath.children)
                        .filter(item => item.tagName === 'SPAN' && item.classList.contains('location-folder'))
                        .map(item => item.textContent.trim());
                        
                    if (pathItems.length > 0) {
                        currentPath = pathItems.join('/');
                        console.log('🔄 Using breadcrumb path:', currentPath);
                    }
                }
            }
            
            console.log('🔄 Final current path for refresh:', currentPath);
            
            // Avoid re-render override if an optimistic lock is active (upload/move)
            // BUT allow refresh for folder moves since they need UI updates
            if (window.optimisticLock && (Date.now() - (window.optimisticLock.timestamp || 0) < 3000)) {
                const lockOperation = window.optimisticLock.operation;
                const documentName = window.optimisticLock.documentName;
                
                // Allow refresh for folder moves, block only for document moves
                if (lockOperation === 'move' && documentName && documentName !== 'Unknown' && documentName !== 'FolderMove') {
                    console.log('🔒 [OPTIMISTIC] Blocking auto refresh to preserve instant UI for document move:', documentName);
                    return;
                } else if (lockOperation !== 'move') {
                    console.log('🔒 [OPTIMISTIC] Blocking auto refresh to preserve instant UI for', lockOperation);
                    return;
                } else {
                    console.log('🔄 [OPTIMISTIC] Allowing refresh for folder move or unknown move operation');
                }
            }
            window.electron.ipcRenderer.send('get-folder-structure', {
                institutionId: window.userData.institution_id,
                currentPath: currentPath
            });
        }

        // Update the grid layout for better spacing - with null check
        const contentGrid = document.querySelector('.content-grid');
        if (contentGrid) {
            contentGrid.style.cssText = `
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
                gap: 1.5rem;
                padding: 1.5rem;
            `;
        }

        // Add bulk move button to the header
        const headerContent = document.querySelector('.header-content');
        const bulkMoveButton = document.createElement('button');
        bulkMoveButton.className = 'px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors duration-300 flex items-center space-x-2';
        bulkMoveButton.innerHTML = `
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4"></path>
            </svg>
        `;
        bulkMoveButton.onclick = () => {
            const selectedDocs = Array.from(document.querySelectorAll('.document-item.selected'))
                .map(item => ({
                    type: 'document',
                    id: item.dataset.documentId,
                    name: item.dataset.documentName,
                    path: item.dataset.documentPath
                }));
            if (selectedDocs.length > 0) {
                showMoveDialog(selectedDocs);
            } else {
                showNotification('Please select documents to move', 'info');
            }
        };
        if (headerContent) {
            headerContent.appendChild(bulkMoveButton);
        }

        // Add selection functionality
        document.addEventListener('click', (e) => {
            const docElement = e.target.closest('.document-item');
            if (docElement) {
                docElement.classList.toggle('selected');
                if (docElement.classList.contains('selected')) {
                    docElement.style.borderColor = '#8B5CF6';
                    // Add selection indicator
                    const indicator = document.createElement('div');
                    indicator.className = 'selection-mode-indicator';
                    indicator.textContent = 'Selection Mode Active';
                    document.body.appendChild(indicator);
                    setTimeout(() => indicator.remove(), 2000);
                } else {
                    docElement.style.borderColor = '#374151';
                }
            }
        });

        // Add this new toast notification system
        function showToast({ title, message, type = 'info', duration = 3000 }) {
            const container = document.getElementById('toastContainer');
            if (!container) {
                console.error('Toast container not found');
                return;
            }

            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            const icon = type === 'success' ? 'check-circle' :
                        type === 'error' ? 'x-circle' :
                        type === 'warning' ? 'exclamation-circle' : 'information-circle';
            
            toast.innerHTML = `
                <div class="toast-icon">
                    <svg class="w-6 h-6 ${type === 'success' ? 'text-green-500' : 
                                        type === 'error' ? 'text-red-500' : 
                                        type === 'warning' ? 'text-yellow-500' : 'text-blue-500'}" 
                         fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                              d="${type === 'success' ? 'M5 13l4 4L19 7' :
                                 type === 'error' ? 'M6 18L18 6M6 6l12 12' :
                                 type === 'warning' ? 'M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z' :
                                 'M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z'}">
                        </path>
                    </svg>
                </div>
                <div class="toast-content">
                    <div class="toast-title">${title}</div>
                    <div class="toast-message">${message}</div>
                </div>
                <button class="toast-close" onclick="this.parentElement.remove()">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            `;

            container.appendChild(toast);
            
            // Force a reflow to ensure the animation works
            toast.offsetHeight;
            
            // Add show class to trigger animation
            toast.classList.add('show');

            // Auto remove after duration
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => {
                    if (toast.parentNode === container) {
                        container.removeChild(toast);
                    }
                }, 300);
            }, duration);
        }

        // Replace the old showNotification function with the new toast system
        function showNotification(message, type = 'info') {
            const title = type === 'success' ? 'Success' :
                         type === 'error' ? 'Error' :
                         type === 'warning' ? 'Warning' : 'Info';
            
            showToast({
                title,
                message,
                type,
                duration: 3000
            });
        }

        // Modern single-use modal for protected operations
        function showProtectedModal(message) {
            try {
                // Remove any existing modal
                const existing = document.getElementById('protectedModal');
                if (existing) existing.remove();
                
                const overlay = document.createElement('div');
                overlay.id = 'protectedModal';
                overlay.style.cssText = 'position:fixed;inset:0;z-index:99999;display:flex;align-items:center;justify-content:center;background:rgba(2,6,23,0.7);backdrop-filter:blur(6px)';
                overlay.innerHTML = `
                    <div class="w-[520px] max-w-[92vw] rounded-2xl border border-slate-700 bg-gradient-to-br from-slate-900 to-slate-800 shadow-2xl">
                        <div class="px-5 py-4 border-b border-slate-700 flex items-center gap-3">
                            <div class="w-9 h-9 rounded-lg bg-red-500/20 flex items-center justify-center">
                                <i class="fas fa-shield-alt text-red-400"></i>
                            </div>
                            <div class="text-slate-100 font-semibold">Acțiune blocată</div>
                        </div>
                        <div class="px-6 py-5 text-slate-300 leading-relaxed">
                            <div class="text-sm">${message || 'Resursa aparține instituției și nu poate fi ștearsă de pe stația locală.'}</div>
                            <div class="text-xs text-slate-400 mt-3">Folderul/documentul a fost restaurat automat pentru a păstra consistența cu serverul instituției. Dacă ai nevoie de ștergere, contactează administratorul.</div>
                        </div>
                        <div class="px-6 py-4 border-t border-slate-700 flex justify-end gap-2">
                            <button id="protectedModalOk" class="px-4 py-2 rounded-lg bg-blue-600 hover:bg-blue-700 text-white">Am înțeles</button>
                        </div>
                    </div>`;
                document.body.appendChild(overlay);
                const btn = overlay.querySelector('#protectedModalOk');
                btn?.addEventListener('click', () => {
                    overlay.remove();
                    window.__syncErrorModalShown = false;
                });
            } catch (e) { console.error('showProtectedModal error', e); }
        }

        // Add these new functions for multi-select functionality
        let isSelectionMode = false;

        function toggleSelectionMode() {
            isSelectionMode = !isSelectionMode;
            const multiSelectBtn = document.getElementById('multiSelectBtn');
            const documentsGrid = document.getElementById('documentsGrid');
            
            if (isSelectionMode) {
                multiSelectBtn.classList.add('active');
                multiSelectBtn.innerHTML = `
                    <i class="fas fa-check-square"></i>
                    <span>${selectedDocuments.size} Selected</span>
                `;
                documentsGrid.classList.add('selection-mode');
            } else {
                multiSelectBtn.classList.remove('active');
                multiSelectBtn.innerHTML = `
                    <i class="fas fa-check-square"></i>
                    <span>Select Multiple</span>
                `;
                documentsGrid.classList.remove('selection-mode');
                selectedDocuments.clear();
                updateSelectionBubbles();
            }
        }

        function updateSelectionBubbles() {
            document.querySelectorAll('.document-item').forEach(item => {
                const bubble = item.querySelector('.selection-bubble');
                if (bubble) {
                    if (selectedDocuments.has(item.dataset.documentId)) {
                        bubble.classList.add('selected');
                        item.classList.add('selected');
                    } else {
                        bubble.classList.remove('selected');
                        item.classList.remove('selected');
                    }
                }
            });
            
            // Update button text
            const multiSelectBtn = document.getElementById('multiSelectBtn');
            if (isSelectionMode) {
                multiSelectBtn.innerHTML = `
                    <i class="fas fa-check-square"></i>
                    <span>${selectedDocuments.size} Selected</span>
                `;
            }
        }

        function createDocumentElement(doc) {
            const docElement = document.createElement('div');
            docElement.className = 'relative group bg-gray-800 rounded-xl shadow-lg hover:shadow-xl transition-all duration-300 border border-gray-700 hover:border-blue-500 transform hover:-translate-y-1';
            docElement.dataset.documentId = doc.id;
            docElement.dataset.documentPath = doc.path;
            docElement.dataset.documentName = doc.name;

            // Add selection bubble
            const selectionBubble = document.createElement('div');
            selectionBubble.className = 'selection-bubble';
            docElement.appendChild(selectionBubble);

            // Document content wrapper
            const content = document.createElement('div');
            content.className = 'p-4';

            // Document metadata header with ovals
            const metadata = document.createElement('div');
            metadata.className = 'flex items-center space-x-2 mb-3';
            metadata.innerHTML = `
                <div class="flex items-center px-2 py-1 bg-blue-900/50 rounded-full text-xs text-blue-300">
                    <svg class="w-3 h-3 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                    ${formatDate(doc.uploadDate)}
                </div>
                <div class="flex items-center px-2 py-1 bg-purple-900/50 rounded-full text-xs text-purple-300">
                    <svg class="w-3 h-3 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                    </svg>
                    ${formatFileSize(doc.size)}
                </div>
            `;

            // Document icon and name section
            const header = document.createElement('div');
            header.className = 'flex items-center space-x-3 mb-4';

            // Document icon
            const icon = document.createElement('div');
            icon.className = 'flex-shrink-0 w-10 h-10 bg-blue-900/50 rounded-lg flex items-center justify-center group-hover:bg-blue-900/70 transition-colors duration-300';
            icon.innerHTML = `
                <svg class="w-6 h-6 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z"></path>
                </svg>
            `;

            // Document info
            const info = document.createElement('div');
            info.className = 'flex-1 min-w-0';

            // Document name with truncation
            const name = document.createElement('h3');
            name.className = 'text-base font-medium text-white truncate group-hover:text-blue-400 transition-colors duration-300';
            name.textContent = doc.name;

            // Action buttons container
            const actions = document.createElement('div');
            actions.className = 'flex items-center justify-end space-x-2 mt-3 pt-3 border-t border-gray-700';

            // View button
            const viewButton = document.createElement('button');
            viewButton.className = 'p-1.5 text-gray-400 hover:text-blue-400 hover:bg-blue-900/30 rounded-lg transition-all duration-300 transform hover:scale-110';
            viewButton.title = 'View Document';
            viewButton.innerHTML = `
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path>
                </svg>
            `;
            viewButton.onclick = (e) => {
                e.stopPropagation();
                showDocumentDetails(doc);
            };

            // Download button
            const downloadButton = document.createElement('button');
            downloadButton.className = 'p-1.5 text-gray-400 hover:text-green-400 hover:bg-green-900/30 rounded-lg transition-all duration-300 transform hover:scale-110';
            downloadButton.title = 'Download Document';
            downloadButton.innerHTML = `
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
                </svg>
            `;
            downloadButton.onclick = (e) => {
                e.stopPropagation();
                downloadDocument(doc.id);
            };

            // Move button
            const moveButton = document.createElement('button');
            moveButton.className = 'p-1.5 text-gray-400 hover:text-purple-400 hover:bg-purple-900/30 rounded-lg transition-all duration-300 transform hover:scale-110';
            moveButton.title = 'Move Document';
            moveButton.innerHTML = `
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4"></path>
                </svg>
            `;
            moveButton.onclick = (e) => {
                e.stopPropagation();
                showMoveDialog([{
                    type: 'document',
                    id: doc.id,
                    name: doc.name,
                    path: doc.path
                }]);
            };

            // Assemble the document card
            info.appendChild(name);
            header.appendChild(icon);
            header.appendChild(info);
            content.appendChild(metadata);
            content.appendChild(header);
            actions.appendChild(viewButton);
            actions.appendChild(downloadButton);
            actions.appendChild(moveButton);
            content.appendChild(actions);

            docElement.appendChild(content);

            // Add click handler for selection
            docElement.addEventListener('click', (e) => {
                if (isSelectionMode) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const docId = docElement.dataset.documentId;
                    if (selectedDocuments.has(docId)) {
                        selectedDocuments.delete(docId);
                    } else {
                        selectedDocuments.add(docId);
                    }
                    
                    updateSelectionBubbles();
                    
                    // If no documents are selected, exit selection mode
                    if (selectedDocuments.size === 0) {
                        toggleSelectionMode();
                    }
                }
            });

            return docElement;
        }

        // Add event listener for multi-select button
        const multiSelectBtn = document.getElementById('multiSelectBtn');
        if (multiSelectBtn) {
            multiSelectBtn.addEventListener('click', () => {
            if (!isSelectionMode) {
                toggleSelectionMode();
            } else if (selectedDocuments.size > 0) {
                // Show move dialog with selected documents
                const selectedDocs = Array.from(selectedDocuments).map(docId => {
                    const docElement = document.querySelector(`[data-document-id="${docId}"]`);
                    return {
                        type: 'document',
                        id: docId,
                        name: docElement.dataset.documentName,
                        path: docElement.dataset.documentPath
                    };
                });
                
                showMoveDialog(selectedDocs);
                toggleSelectionMode(); // Exit selection mode after showing dialog
            }
            });
        }

        // Enhanced drag and drop functionality
        function handleDragStart(e) {
            const itemData = {
                type: this.classList.contains('folder-item') ? 'folder' : 'document',
                id: this.dataset.documentId || this.dataset.folderPath,
                name: this.querySelector('.folder-name, .document-name').textContent
            };
            this.dataset.dragData = JSON.stringify(itemData);
            this.classList.add('dragging');
        }

        function handleDragEnd(e) {
            this.classList.remove('dragging');
            delete this.dataset.dragData;
        }

        function handleDragOver(e) {
            e.preventDefault();
            if (this.classList.contains('folder-item')) {
                this.classList.add('drag-over');
            }
        }

        function handleDragLeave(e) {
            e.preventDefault();
            this.classList.remove('drag-over');
        }

        function handleDrop(e) {
            e.preventDefault();
            this.classList.remove('drag-over');
            
            const draggedElement = document.querySelector('.dragging');
            if (!draggedElement || !draggedElement.dataset.dragData) return;

            try {
                const data = JSON.parse(draggedElement.dataset.dragData);
                const targetFolder = this.dataset.folderPath;
                
                // Show move animation
                const moveAnimation = document.createElement('div');
                moveAnimation.className = 'move-animation';
                moveAnimation.style.position = 'fixed';
                moveAnimation.style.top = e.clientY + 'px';
                moveAnimation.style.left = e.clientX + 'px';
                moveAnimation.style.width = '50px';
                moveAnimation.style.height = '50px';
                moveAnimation.style.background = '#8B5CF6';
                moveAnimation.style.borderRadius = '50%';
                moveAnimation.style.opacity = '0.5';
                moveAnimation.style.transform = 'translate(-50%, -50%)';
                moveAnimation.style.animation = 'moveToTarget 0.5s ease-out forwards';
                document.body.appendChild(moveAnimation);
                
                setTimeout(() => {
                    moveAnimation.remove();
                    showMoveDialog([{
                        type: data.type,
                        id: data.id,
                        name: data.name
                    }]);
                }, 500);
            } catch (error) {
                console.error('Error handling drop:', error);
                showNotification('Error', 'Failed to move item');
            }
        }

        // Add click handler for document selection
        document.addEventListener('click', (e) => {
            const docElement = e.target.closest('.document-item');
            if (docElement && isSelectionMode) {
                e.preventDefault();
                e.stopPropagation();
                
                toggleDocumentSelection(docElement);
                
                // Show selection mode indicator
                const indicator = document.createElement('div');
                indicator.className = 'selection-mode-indicator';
                indicator.textContent = `${selectedDocuments.size} items selected`;
                document.body.appendChild(indicator);
                
                // Remove indicator after animation
                setTimeout(() => {
                    indicator.style.animation = 'slideOut 0.3s ease-out forwards';
                    setTimeout(() => indicator.remove(), 300);
                }, 2000);
            }
        });

        // Add sorting functions
        function sortDocuments(documents, sortBy) {
            const [field, direction] = sortBy.split('_');
            const isAscending = direction === 'asc';
            
            return [...documents].sort((a, b) => {
                let comparison = 0;
                
                switch (field) {
                    case 'name':
                        comparison = a.name.localeCompare(b.name);
                        break;
                    case 'date':
                        // Handle invalid dates by using a fallback date
                        const dateA = new Date(a.uploadDate);
                        const dateB = new Date(b.uploadDate);
                        
                        // Check if dates are valid
                        const isValidDateA = !isNaN(dateA.getTime());
                        const isValidDateB = !isNaN(dateB.getTime());
                        
                        if (!isValidDateA && !isValidDateB) {
                            comparison = 0; // Both dates are invalid, treat as equal
                        } else if (!isValidDateA) {
                            comparison = isAscending ? 1 : -1; // Invalid date goes last
                        } else if (!isValidDateB) {
                            comparison = isAscending ? -1 : 1; // Invalid date goes last
                        } else {
                            comparison = dateA.getTime() - dateB.getTime();
                        }
                        break;
                    case 'size':
                        comparison = parseInt(a.size) - parseInt(b.size);
                        break;
                    default:
                        comparison = 0;
                }
                
                return isAscending ? comparison : -comparison;
            });
        }

        // Enhanced sort change event listener with animation
        const sortByElement = document.getElementById('sortBy');
        if (sortByElement) {
            sortByElement.addEventListener('change', (e) => {
            const documentsGrid = document.getElementById('documentsGrid');
            const documents = Array.from(documentsGrid.children).map(element => ({
                id: element.dataset.documentId,
                name: element.dataset.documentName,
                path: element.dataset.documentPath,
                size: parseInt(element.querySelector('.bg-purple-900\\/50').textContent.match(/\d+/)[0]),
                uploadDate: element.querySelector('.bg-blue-900\\/50').textContent
            }));
            
            // Add fade out animation
            documentsGrid.style.opacity = '0';
            documentsGrid.style.transform = 'translateY(10px)';
            
            setTimeout(() => {
                // Clear and repopulate with sorted documents
                documentsGrid.innerHTML = '';
                const sortedDocuments = sortDocuments(documents, e.target.value);
                
                sortedDocuments.forEach((doc, index) => {
                    const docElement = createDocumentElement(doc);
                    docElement.style.opacity = '0';
                    docElement.style.transform = 'translateY(10px)';
                    documentsGrid.appendChild(docElement);
                    
                    // Stagger the fade in animation
                    setTimeout(() => {
                        docElement.style.transition = 'all 0.3s ease-out';
                        docElement.style.opacity = '1';
                        docElement.style.transform = 'translateY(0)';
                    }, index * 50);
                });
                
                // Fade in the grid
                documentsGrid.style.transition = 'all 0.3s ease-out';
                documentsGrid.style.opacity = '1';
                documentsGrid.style.transform = 'translateY(0)';
            }, 300);
            });
        }

        // Initialize drag and drop functionality
        function initializeDragAndDrop() {
            console.log('Initializing drag and drop functionality...');
            
            // Get the drop zone elements from Upload Center
            const uploadDropArea = document.getElementById('uploadDropArea');
            const folderDropArea = document.getElementById('folderDropArea');
            
            if (uploadDropArea || folderDropArea) {
                console.log('Upload drop zone elements found, adding event listeners...');
                
                // Add event listeners to both drop areas
                [uploadDropArea, folderDropArea].forEach(element => {
                    if (element) {
                        element.addEventListener('dragover', handleDropZoneDragOver);
                        element.addEventListener('dragenter', handleDropZoneDragEnter);
                        element.addEventListener('dragleave', handleDropZoneDragLeave);
                        element.addEventListener('drop', handleDropZoneDrop);
                        console.log('Added drag & drop listeners to:', element.id);
                    }
                });
                
                // Also prevent default behavior on the document to ensure drops work
                document.addEventListener('dragover', (e) => e.preventDefault());
                document.addEventListener('drop', (e) => {
                    // Only prevent default if not dropping on our drop zone
                    if (!e.target.closest('#uploadDropArea') && !e.target.closest('#folderDropArea')) {
                        e.preventDefault();
                    }
                });
                
                console.log('Drag and drop event listeners added successfully');
            } else {
                console.error('Upload drop zone elements not found!');
                console.log('uploadDropArea:', uploadDropArea);
                console.log('folderDropArea:', folderDropArea);
            }
        }

        // Initialize drag and drop when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, initializing drag and drop...');
            console.log('TESTING: DOM content loaded, checking buttons...');
            setTimeout(() => {
                const uploadFilesBtn = document.getElementById('uploadFilesBtn');
                const uploadFolderBtn = document.getElementById('uploadFolderBtn'); 
                const openUploadCenterBtn = document.getElementById('openUploadCenterBtn');
                console.log('TESTING: Button elements found:', {
                    uploadFilesBtn: !!uploadFilesBtn,
                    uploadFolderBtn: !!uploadFolderBtn,
                    openUploadCenterBtn: !!openUploadCenterBtn
                });
                if (uploadFilesBtn) {
                    console.log('TESTING: uploadFilesBtn style:', uploadFilesBtn.style.cssText);
                    console.log('TESTING: uploadFilesBtn offsetParent:', uploadFilesBtn.offsetParent);
                    console.log('TESTING: uploadFilesBtn display:', getComputedStyle(uploadFilesBtn).display);
                    console.log('TESTING: uploadFilesBtn visibility:', getComputedStyle(uploadFilesBtn).visibility);
                    console.log('TESTING: uploadFilesBtn pointer-events:', getComputedStyle(uploadFilesBtn).pointerEvents);
                }
            }, 1000);
            initializeDragAndDrop();
            // Upload buttons
            const filesBtn = document.getElementById('uploadFilesBtn');
            const folderBtn = document.getElementById('uploadFolderBtn');
            const openCenterBtn = document.getElementById('openUploadCenterBtn');
            const filesInput = document.getElementById('uploadFilesInput');
            console.log('[UPLOAD] Elements present:', {
                filesBtn: !!filesBtn,
                folderBtn: !!folderBtn,
                openCenterBtn: !!openCenterBtn,
                filesInput: !!filesInput,
                uploadModal: !!document.getElementById('uploadModal')
            });
            // Also expose a global opener to avoid timing issues
            window.openUploadModal = (mode) => {
                console.log('[UPLOAD] openUploadModal called with mode:', mode);
                const modal = document.getElementById('uploadModal');
                if (!modal) { console.warn('[UPLOAD] uploadModal element NOT FOUND'); return; }
                modal.classList.remove('hidden');
                console.log('[UPLOAD] uploadModal opened');
            };
            window.openUploadCenter = (initialTab) => {
                console.log('[UPLOAD] openUploadCenter called with tab:', initialTab);
                const modal = document.getElementById('uploadModal');
                if (!modal) {
                    console.error('[UPLOAD] Modal not found!');
                    return;
                }
                console.log('[UPLOAD] Modal found, opening...');
                modal.classList.remove('hidden');
                modal.style.display = 'flex';
                
                // Initialize drag & drop when modal opens
                setTimeout(() => {
                    console.log('[UPLOAD] Initializing drag & drop for Upload Center...');
                    initializeDragAndDrop();
                }, 100);
                
                const isFiles = (initialTab || 'files') === 'files';
                const tabF = document.getElementById('tabFiles');
                const tabD = document.getElementById('tabFolders');
                const hint = document.getElementById('dropHint');
                const modalChooseFiles = document.getElementById('modalChooseFiles');
                const modalChooseFolder = document.getElementById('modalChooseFolder');
                
                console.log('[UPLOAD] Tab elements found:', { tabF: !!tabF, tabD: !!tabD, hint: !!hint });
                
                if (tabF && tabD && hint) {
                    if (isFiles) {
                        tabF.className = 'px-3 py-1.5 rounded bg-blue-600 text-white';
                        tabD.className = 'px-3 py-1.5 rounded bg-slate-700 text-slate-200';
                        hint.textContent = 'Trage și plasează PDF-uri aici';
                        if (modalChooseFiles) modalChooseFiles.style.display = 'inline-block';
                        if (modalChooseFolder) modalChooseFolder.style.display = 'none';
                    } else {
                        tabD.className = 'px-3 py-1.5 rounded bg-blue-600 text-white';
                        tabF.className = 'px-3 py-1.5 rounded bg-slate-700 text-slate-200';
                        hint.textContent = 'Trage și plasează foldere aici';
                        if (modalChooseFiles) modalChooseFiles.style.display = 'none';
                        if (modalChooseFolder) modalChooseFolder.style.display = 'inline-block';
                    }
                }
                console.log('[UPLOAD] uploadCenter opened, activeTab:', isFiles ? 'files' : 'folder');
            };
            // Fallback event listeners
            if (filesBtn) filesBtn.addEventListener('click', () => { console.log('[UPLOAD] Click: uploadFilesBtn'); window.openUploadModal('files'); });
            if (folderBtn) folderBtn.addEventListener('click', () => { console.log('[UPLOAD] Click: uploadFolderBtn'); window.openUploadModal('folder'); });
            if (openCenterBtn) openCenterBtn.addEventListener('click', () => { console.log('[UPLOAD] Click: openUploadCenterBtn'); window.openUploadCenter('files'); });
            
            // Add event listener for institution folder button
            const openInstitutionFolderBtn = document.getElementById('openInstitutionFolderBtn');
            if (openInstitutionFolderBtn) {
                openInstitutionFolderBtn.addEventListener('click', () => { 
                    console.log('[FOLDER] Click: openInstitutionFolderBtn'); 
                    window.openInstitutionFolder(); 
                });
            }

            // Upload Modal wiring
            const closeUploadModal = document.getElementById('closeUploadModal');
            if (closeUploadModal) closeUploadModal.addEventListener('click', () => { console.log('[UPLOAD] Click: closeUploadModal'); document.getElementById('uploadModal')?.classList.add('hidden'); });
            
            // Close modal on overlay click
            const uploadModal = document.getElementById('uploadModal');
            if (uploadModal) {
                uploadModal.addEventListener('click', (e) => {
                    if (e.target === uploadModal) {
                        console.log('[UPLOAD] Click: overlay close');
                        uploadModal.classList.add('hidden');
                    }
                });
            }
            
            // Close modal with Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    const modal = document.getElementById('uploadModal');
                    if (modal && !modal.classList.contains('hidden')) {
                        console.log('[UPLOAD] Escape key: closing modal');
                        modal.classList.add('hidden');
                    }
                }
            });
            const tabFiles = document.getElementById('tabFiles');
            const tabFolders = document.getElementById('tabFolders');
            if (tabFiles) tabFiles.addEventListener('click', () => window.openUploadCenter('files'));
            if (tabFolders) tabFolders.addEventListener('click', () => window.openUploadCenter('folder'));
            // PDF drag & drop setup will be done when tab is activated
            console.log('[UPLOAD] PDF drag & drop will be initialized when Files tab is activated');
            // Wire preview buttons
            const clearBtn = document.getElementById('clearSelectedFiles');
            const uploadBtn = document.getElementById('startUploadFiles');
            if (clearBtn) clearBtn.addEventListener('click', window.clearSelectedFiles);
            if (uploadBtn) uploadBtn.addEventListener('click', window.startUploadFiles);
            const modalChooseFolder = document.getElementById('modalChooseFolder');
            if (modalChooseFolder) modalChooseFolder.addEventListener('click', async () => {
                console.log('[UPLOAD] Click: modalChooseFolder');
                try {
                    const { ipcRenderer } = require('electron');
                    const res = await ipcRenderer.invoke('select-upload-folder');
                    if (!res || res.canceled || !res.path) return;
                    const targetPath = (window.currentFolderPath || '').replace(/^\/+|\/+$/g, '');
                    ipcRenderer.send('add-folder', { folderPath: res.path, targetPath });
                    document.getElementById('uploadModal')?.classList.add('hidden');
                } catch (err) { console.error('Folder picker failed:', err); }
            });

            // Global delegated clicks as a safety net (nodes can be re-rendered)
            document.addEventListener('click', (evt) => {
                const t = evt.target;
                if (t.closest('#uploadFilesBtn')) {
                    console.log('[UPLOAD][DELEGATE] Click: uploadFilesBtn');
                    evt.preventDefault();
                    if (typeof window.openUploadCenter === 'function') window.openUploadCenter('files');
                    return;
                }
                if (t.closest('#uploadFolderBtn')) {
                    console.log('[UPLOAD][DELEGATE] Click: uploadFolderBtn');
                    evt.preventDefault();
                    if (typeof window.openUploadCenter === 'function') window.openUploadCenter('folder');
                    return;
                }
                if (t.closest('#openUploadCenterBtn')) {
                    console.log('[UPLOAD][DELEGATE] Click: openUploadCenterBtn');
                    evt.preventDefault();
                    if (typeof window.openUploadCenter === 'function') window.openUploadCenter('files');
                    return;
                }
                if (t.closest('#openInstitutionFolderBtn')) {
                    console.log('[FOLDER][DELEGATE] Click: openInstitutionFolderBtn');
                    evt.preventDefault();
                    if (typeof window.openInstitutionFolder === 'function') window.openInstitutionFolder();
                    return;
                }
                if (t.closest('#closeUploadModal')) {
                    console.log('[UPLOAD][DELEGATE] Click: closeUploadModal');
                    document.getElementById('uploadModal')?.classList.add('hidden');
                    return;
                }
                if (t.closest('#tabFiles')) {
                    console.log('[UPLOAD][DELEGATE] Click: tabFiles');
                    if (typeof window.openUploadCenter === 'function') window.openUploadCenter('files');
                    return;
                }
                if (t.closest('#tabFolders')) {
                    console.log('[UPLOAD][DELEGATE] Click: tabFolders');
                    if (typeof window.openUploadCenter === 'function') window.openUploadCenter('folder');
                    return;
                }
                if (t.closest('#modalChooseFiles')) {
                    console.log('[UPLOAD][DELEGATE] Click: modalChooseFiles');
                    return; // actual picker already wired above
                }
                if (t.closest('#modalChooseFolder')) {
                    console.log('[UPLOAD][DELEGATE] Click: modalChooseFolder');
                    return; // actual picker already wired above
                }
            }, true); // capture phase to avoid stopPropagation blockers

            // Low-level pointer debug to ensure clicks really reach the page
            document.addEventListener('pointerdown', (e) => {
                const el = e.target;
                const id = el.id ? `#${el.id}` : '';
                const cls = el.className ? `.${(el.className+'').toString().split(/\s+/).slice(0,3).join('.')}` : '';
                console.log('[POINTER] down on', el.tagName + id + cls);
            }, true);
        });

        // ✅ ADD LISTENER FOR FRESH FOLDER DATA FROM BACKEND
        window.addEventListener('fresh-folder-data', (event) => {
            console.log('\n🔄 === RECEIVED FRESH FOLDER DATA FROM BACKEND ===');
            console.log('📦 Fresh data:', JSON.stringify(event.detail, null, 2));
            
            const data = event.detail;
            
            // Skip if move dialog is open
            if (isMoveDialogOpen) {
                console.log('DEBUG: Skipping fresh folder update - move dialog is open');
                return;
            }
            
            const folderList = document.getElementById('folderTree');
            const documentsGrid = document.getElementById('documentsGrid');
            
            if (!folderList || !documentsGrid) {
                console.error('DEBUG: Required DOM elements not found');
                return;
            }
            
            // ✅ SET CURRENT FOLDER PATH FROM FRESH DATA
            window.currentFolderPath = data.currentPath || '';
            console.log('✅ DEBUG: Set window.currentFolderPath from fresh data to:', window.currentFolderPath);
            
            // Clear existing content
            folderList.innerHTML = '';
            documentsGrid.innerHTML = '';
            
            // Update breadcrumb
            updateBreadcrumb(data.currentPath);
            
            // Display folders
            if (data.folders && data.folders.length > 0) {
                console.log('DEBUG: Displaying fresh folders:', data.folders);
                data.folders.forEach(folder => {
                    const folderElement = document.createElement('div');
                    folderElement.className = 'folder-item';
                    folderElement.setAttribute('data-path', folder.path);
                    
                    folderElement.innerHTML = `
                        <div class="folder-icon">
                            <i class="fas fa-folder"></i>
                        </div>
                        <div class="folder-info">
                            <div class="folder-name">${folder.name}</div>
                            <div class="folder-details">
                                <span>${folder.documentCount || 0} documents</span>
                            </div>
                        </div>
                    `;
                    
                    folderElement.onclick = () => {
                        folderHistory.push(data.currentPath);
                        updateBreadcrumb(folder.path);
                        
                        // Set current folder path globally
                        window.currentFolderPath = folder.path;
                        console.log('DEBUG: Set window.currentFolderPath to:', folder.path);
                        
                        window.electron.ipcRenderer.send('get-folder-structure', {
                            institutionId: window.userData.institution_id,
                            currentPath: folder.path
                        });
                    };
                    
                    folderList.appendChild(folderElement);
                });
            }
            
            // Display documents with sorting
            if (data.documents && data.documents.length > 0) {
                console.log('✅ DEBUG: Displaying FRESH documents:', data.documents.length);
                const sortBy = document.getElementById('sortBy').value;
                const sortedDocuments = sortDocuments(data.documents, sortBy);
                
                sortedDocuments.forEach(doc => {
                    const docElement = createDocumentElement(doc);
                    documentsGrid.appendChild(docElement);
                });
                
                // Only show notification if this is NOT a move operation from dialog
                // This prevents duplicate notifications
                if (!window.isProcessingMove) {
                    const eventType = data.eventType || 'move';
                    let notificationTitle = 'Document Updated';
                    let notificationMessage = 'Document updated and visible in real-time!';
                    
                    if (eventType.includes('move')) {
                        notificationTitle = 'Document Moved';
                        notificationMessage = 'Document successfully moved and visible in real-time!';
                    } else if (eventType.includes('delete')) {
                        notificationTitle = 'Document Deleted';
                        notificationMessage = 'Document moved to recycle bin in real-time!';
                    } else if (eventType.includes('restore')) {
                        notificationTitle = 'Document Restored';
                        notificationMessage = 'Document restored from recycle bin in real-time!';
                    } else if (eventType.includes('add') || eventType.includes('upload')) {
                        notificationTitle = 'Document Added';
                        notificationMessage = 'Document uploaded and visible in real-time!';
                    }
                    
                    showToast({
                        title: notificationTitle,
                        message: notificationMessage,
                        type: 'success',
                        duration: 3000
                    });
                }
            }
        });

        // Also initialize after a short delay to ensure all elements are loaded
        setTimeout(() => {
            console.log('Backup initialization of drag and drop...');
            initializeDragAndDrop();
        }, 1000);

        // ========== NEW UI FUNCTIONS (FolderSidebar + Documents) ==========
        
        // displayFolders already defined early - no need to redefine
        

        
        // Build hierarchical folder tree (copied from FolderSidebar)
        function buildFolderTree(folders) {
            if (!folders || folders.length === 0) return [];

            // console.log('🌳 Building folder tree for', folders.length, 'folders');
            
            // DEBUG: Show first 10 folders with their paths
            // console.log('📂 First 10 folders with paths:');
            // folders.slice(0, 10).forEach((folder, i) => {
            //     console.log(`  ${i+1}. ${folder.folder_name || folder.name} -> path: "${folder.folder_path}" (${(folder.folder_path || '').split('/').length} parts)`);
            // });

            // Get root folders (level 1) - folders directly under institution
            const rootFolders = folders.filter(folder => {
                // Handle both / and \ path separators
                const pathParts = (folder.folder_path || '').split(/[/\\]+/);
                const isRoot = pathParts.length === 2; // Only folders directly under institution
                
                // DEBUG: Log all folders to see filtering
                // console.log(`🔍 Folder: "${folder.folder_name}" path: "${folder.folder_path}" parts: ${pathParts.length} [${pathParts.join(' | ')}] isRoot: ${isRoot}`);
                
                return isRoot;
            });

            // Build tree structure recursively
            const buildChildren = (parentPath) => {
                return folders.filter(folder => {
                    const folderPath = folder.folder_path || '';
                    return folderPath.startsWith(parentPath + '/') && 
                           folderPath.split('/').length === parentPath.split('/').length + 1;
                }).map(folder => ({
                    ...folder,
                    children: buildChildren(folder.folder_path)
                }));
            };

            // Build complete tree
            const tree = rootFolders.map(folder => ({
                ...folder,
                children: buildChildren(folder.folder_path)
            }));

            // console.log('✅ Folder tree built:', tree.length, 'root folders');
            // console.log('📁 Root folders list:', tree.map(f => f.folder_name || f.name));
            return tree;
        }

        // Function to render folder tree in sidebar with hierarchical structure
        function renderFolderTree(folders, currentPath = '') {
            // console.debug('🗂️ Rendering folders');
            const folderTree = document.getElementById('folderTree');
            if (!folderTree) return;
            
            folderTree.innerHTML = '';
            
            if (!folders || folders.length === 0) {
                folderTree.innerHTML = '<div class="text-slate-500 text-sm p-2">No folders found</div>';
                return;
            }

            // Build hierarchical tree structure
            const hierarchicalFolders = buildFolderTree(folders);
            // console.debug('🌳 Hierarchical folders:', hierarchicalFolders.length);
            
            // Render folders recursively with expand/collapse
            function renderFolderLevel(foldersToRender, level = 0) {
                foldersToRender.forEach(folder => {
                    const hasChildren = folder.children && folder.children.length > 0;
                    const isExpanded = expandedFolders.has(folder.id);
                    const isSelected = window.currentFolder?.id === folder.id;
                    
                    // Create folder element - extra compact list row
                    const folderElement = document.createElement('div');
                    folderElement.className = 'folder-item mb-0.5';
                    // Keep boxes aligned to the left, no margin on container
                    
                    folderElement.innerHTML = `
                        <div class="flex items-center py-1 px-1.5 rounded hover:bg-slate-800 transition-colors cursor-pointer text-xs ${isSelected ? 'bg-slate-700 border-l-2 border-blue-500' : ''}">
                            <div style="margin-left: ${level * 16}px; display: flex; align-items: center;">
                                ${hasChildren ? 
                                    `<button class="expand-btn w-3 h-3 mr-1 text-gray-400 hover:text-blue-400 transition-colors">
                                        <i class="fas fa-chevron-right text-[10px] transform transition-transform ${isExpanded ? 'rotate-90' : ''}"></i>
                                    </button>` : 
                                    '<div class="w-4 mr-1"></div>'
                                }
                                <i class="fas ${isExpanded ? 'fa-folder-open' : 'fa-folder'} text-blue-400 text-[11px] mr-1.5"></i>
                                <span class="text-slate-300 text-xs">${folder.folder_name || folder.name || 'Unnamed Folder'}</span>
                                ${folder.is_private ? '<i class="fas fa-lock text-yellow-400 text-[10px] ml-1" title="Folder privat"></i>' : ''}
                                ${hasChildren ? `<span class="text-[10px] text-slate-500 ml-1">(${folder.children.length})</span>` : ''}
                            </div>
                        </div>
                    `;
                    
                    // Add click event for folder navigation - make entire folder box clickable
                    folderElement.addEventListener('click', (e) => {
                        if (!e.target.closest('.expand-btn')) {
                            navigateToFolder(folder);
                        }
                    });

                    // Enable drop target for moving documents into this folder
                    folderElement.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        folderElement.classList.add('drag-over');
                    });
                    folderElement.addEventListener('dragleave', () => {
                        folderElement.classList.remove('drag-over');
                    });
                    folderElement.addEventListener('drop', (e) => {
                        e.preventDefault();
                        folderElement.classList.remove('drag-over');
                        try {
                            const json = e.dataTransfer.getData('application/json') || e.dataTransfer.getData('text/plain');
                            if (!json) return;
                            const payload = JSON.parse(json);
                            const destinationPath = folder.folder_path || folder.path || '';
                            const moveData = {
                                documentId: payload.documentId || null,
                                documentName: payload.documentName,
                                sourcePath: payload.sourcePath || '',
                                destinationPath
                            };
                            window.electron.ipcRenderer.send('move-document', moveData);
                        } catch (err) {
                            console.error('Drop parse error:', err);
                        }
                    });
                    
                    // Add expand/collapse functionality
                    if (hasChildren) {
                        const expandBtn = folderElement.querySelector('.expand-btn');
                        expandBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            if (isExpanded) {
                                expandedFolders.delete(folder.id);
                            } else {
                                expandedFolders.add(folder.id);
                            }
                            // Re-render subtree only
                            renderFolderTree(folders, currentPath);
                        });
                    }
                    
                    folderTree.appendChild(folderElement);
                    
                    // Render children if expanded
                    if (hasChildren && isExpanded) {
                        renderFolderLevel(folder.children, level + 1);
                    }
                });
            }
            
            // Start rendering from root level
            renderFolderLevel(hierarchicalFolders);
        }
        
        // Function to render documents grid (similar to Diffuse.js)
        function renderDocumentsGrid(documents) {
            console.log('🎨 [RENDER] renderDocumentsGrid called with:', {
                documents: documents,
                length: documents?.length,
                isArray: Array.isArray(documents)
            });
            
            const documentsGrid = document.getElementById('documentsGrid');
            const emptyState = document.getElementById('emptyState');
            
            if (!documentsGrid || !emptyState) {
                console.log('❌ [RENDER] Required DOM elements not found');
                return;
            }
            
            if (!documents || documents.length === 0) {
                console.log('🎨 [RENDER] No documents, showing empty state');
                documentsGrid.style.display = 'none';
                emptyState.style.display = 'block';
                return;
            }
            
            console.log('🎨 [RENDER] Rendering', documents.length, 'documents');
            
            documentsGrid.style.display = 'grid';
            emptyState.style.display = 'none';
            documentsGrid.innerHTML = '';
            
            documents.forEach(doc => {
                const docElement = document.createElement('div');
                docElement.className = `
                    bg-slate-700 rounded-lg p-4 border border-slate-600
                    hover:bg-slate-600 hover:border-blue-500/30 
                    transition-all duration-200 cursor-pointer group
                    transform hover:scale-105 hover:shadow-lg
                `;
                // Make draggable for folder drop
                docElement.draggable = true;
                const sourceFolderPath = (doc.path && typeof doc.path === 'string' ? doc.path : (window.currentFolderPath || ''));
                docElement.dataset.documentName = doc.name;
                docElement.dataset.sourcePath = sourceFolderPath;
                
                const fileSize = formatFileSize(doc.size || 0);
                const uploadDate = new Date(doc.uploadDate).toLocaleDateString();
                
                docElement.innerHTML = `
                    <div class="flex items-center justify-between mb-3">
                        <div class="w-8 h-8 bg-red-500/20 rounded-lg flex items-center justify-center">
                            <i class="fas fa-file-pdf text-red-400"></i>
                        </div>
                        <div class="text-xs text-slate-400">${fileSize}</div>
                    </div>
                    <h3 class="text-slate-200 font-medium text-sm mb-2 truncate" title="${doc.name}">
                        ${doc.name}
                    </h3>
                    <div class="text-xs text-slate-400 space-y-1">
                        <div>📅 ${uploadDate}</div>
                        <div>👤 ${doc.uploader || 'Unknown'}</div>
                        ${doc.type ? `<div class="inline-block bg-blue-500/20 text-blue-300 px-2 py-1 rounded text-xs">${doc.type}</div>` : ''}
                    </div>
                    <div class="mt-3 flex space-x-2 opacity-0 group-hover:opacity-100 transition-opacity">
                        <button class="flex-1 bg-blue-600 hover:bg-blue-700 text-white text-xs py-1 px-2 rounded">
                            <i class="fas fa-eye mr-1"></i>View
                        </button>
                        <button class="flex-1 bg-green-600 hover:bg-green-700 text-white text-xs py-1 px-2 rounded">
                            <i class="fas fa-download mr-1"></i>Download
                        </button>
                    </div>
                `;
                
                // Add click handler for document viewing
                docElement.addEventListener('click', () => {
                    viewDocument(doc);
                });

                // Drag start: send minimal info
                docElement.addEventListener('dragstart', (e) => {
                    const payload = {
                        documentId: doc.id || null,
                        documentName: doc.name,
                        sourcePath: sourceFolderPath
                    };
                    e.dataTransfer.setData('application/json', JSON.stringify(payload));
                    e.dataTransfer.effectAllowed = 'move';
                });
                
                documentsGrid.appendChild(docElement);
            });
        }
        
        // Function to navigate to folder
        function navigateToFolder(folder) {
            // Prevent redundant reloads if same folder is clicked
            if (window.currentFolder && (window.currentFolder.id === folder.id)) {
                return;
            }
            // console.debug('🗂️ Navigating to folder');
            
            // Store current folder globally
            window.currentFolder = folder;
            
            // Update breadcrumb
            const breadcrumb = document.getElementById('currentPathBreadcrumb');
            const folderInfo = document.getElementById('currentFolderInfo');
            
            if (breadcrumb) {
                breadcrumb.textContent = folder.folder_name || folder.name || 'Root';
            }
            if (folderInfo) {
                folderInfo.textContent = folder.folder_path || folder.path || 'Root';
            }
            
            // Update Document Explorer header
            const documentExplorerTitle = document.querySelector('#documentExplorer .text-white');
            if (documentExplorerTitle) {
                documentExplorerTitle.textContent = `Document Explorer - ${folder.folder_name || folder.name || 'Root'}`;
            }
            
            // Re-render folder tree to update selection
            // Do not rebuild the tree here to avoid flicker; selection will update on next data push
            
            // Load documents for this specific folder
            loadDocumentsForFolder(folder.folder_path || folder.path || '');
        }
        
        // Function to load documents for a specific folder
        async function loadDocumentsForFolder(folderPath) {
            // Avoid noisy logs; keep one concise line
            // console.debug('📄 Load docs for:', folderPath);
            
            try {
                // Load REAL documents from API
                const result = await require('electron').ipcRenderer.invoke('load-documents-for-folder', folderPath);
                
                if (result.success && result.documents) {
                    // Persist for optimistic flows
                    window.lastDocuments = Array.isArray(result.documents) ? result.documents : [];
                    renderDocumentsGrid(window.lastDocuments);
                } else {
                    window.lastDocuments = [];
                    renderDocumentsGrid([]);
                }
            } catch (error) {
                console.error('❌ Error loading documents:', error);
                // Fallback to mock documents for demonstration
                const mockDocuments = [
                    {
                        id: Math.random(),
                        name: `Sample Document 1.pdf`,
                        path: folderPath,
                        type: 'PDF',
                        size: 2500000, // 2.5 MB
                        uploadDate: new Date().toISOString(),
                        thumbnail: null
                    },
                    {
                        id: Math.random(),
                        name: `Report ${new Date().getFullYear()}.pdf`,
                        path: folderPath,
                        type: 'PDF', 
                        size: 1800000, // 1.8 MB
                        uploadDate: new Date(Date.now() - 86400000).toISOString(), // Yesterday
                        thumbnail: null
                    }
                ];
                
                console.log('📄 Mock documents for folder:', mockDocuments);
                window.lastDocuments = mockDocuments;
                renderDocumentsGrid(window.lastDocuments);
            }
        }
        
        // Function to view document - redirect to modal
        function viewDocument(document) {
            console.log('Viewing document:', document);
            showDocumentDetails(document);
        }
        

        
        // Function to update user info
        function updateUserInfo() {
            const userData = window.userData || {};
            const userNameEl = document.getElementById('userName');
            const userInstitutionEl = document.getElementById('userInstitution');
            
            if (userNameEl) {
                const fullName = `${userData.firstName || 'undefined'} ${userData.lastName || 'undefined'}`;
                userNameEl.textContent = fullName;
            }
            
            if (userInstitutionEl && userData.institution_name) {
                userInstitutionEl.textContent = userData.institution_name;
            }
        }
        
        // Initialize new UI when document is ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🎨 Initializing new Sync Agent UI...');
            
            // Add event listeners for new UI elements
            const backToRoot = document.getElementById('backToRoot');
            if (backToRoot) {
                backToRoot.addEventListener('click', () => {
                    navigateToFolder({ name: 'Root', path: '' });
                });
            }
            
            // Update button IDs to match new HTML
            const testFoldersBtn = document.getElementById('testFolders');
            const testDocumentsBtn = document.getElementById('testDocuments');
            
            if (testFoldersBtn) {
                testFoldersBtn.addEventListener('click', async () => {
                    console.log('🧪 Testing folders API...');
                    try {
                        const result = await require('electron').ipcRenderer.invoke('test-load-folders');
                        console.log('🧪 Folders test result:', result);
                        if (result.success) {
                            console.log('✅ Folders test successful');
                        } else {
                            console.log('❌ Folders test failed:', result.message);
                            console.log('Details:', result.details);
                        }
                    } catch (error) {
                        console.error('❌ Error testing folders:', error);
                    }
                });
            }
            
            if (testDocumentsBtn) {
                testDocumentsBtn.addEventListener('click', async () => {
                    console.log('🧪 Testing documents API...');
                    try {
                        const result = await require('electron').ipcRenderer.invoke('test-load-documents');
                        console.log('🧪 Documents test result:', result);
                        if (result.success) {
                            console.log('✅ Documents test successful');
                        } else {
                            console.log('❌ Documents test failed:', result.message);
                            console.log('Details:', result.details);
                        }
                    } catch (error) {
                        console.error('❌ Error testing documents:', error);
                    }
                });
            }
        });

        // Sync Progress Modal Functions
        function showSyncProgress() {
            const modal = document.getElementById('syncProgressModal');
            if (modal) {
                modal.classList.remove('hidden');
            }
        }

        // Function to update sync progress
        function updateSyncProgress(data) {
            const {
                title = 'Sincronizare în curs...',
                status = '',
                progress = 0,
                foldersCount = 0,
                documentsDownloaded = 0,
                documentsTotal = 0,
                currentFile = '',
                speed = ''
            } = data;

            // Update elements
            const titleEl = document.getElementById('syncTitle');
            const statusEl = document.getElementById('syncStatus');
            const progressBarEl = document.getElementById('syncProgressBar');
            const foldersCountEl = document.getElementById('foldersCount');
            const documentsCountEl = document.getElementById('documentsCount');
            const currentFileEl = document.getElementById('currentFile');
            const speedEl = document.getElementById('downloadSpeed');

            if (titleEl) titleEl.textContent = title;
            if (statusEl) statusEl.textContent = status;
            if (progressBarEl) progressBarEl.style.width = `${progress}%`;
            if (foldersCountEl) foldersCountEl.textContent = foldersCount;
            if (documentsCountEl) documentsCountEl.textContent = `${documentsDownloaded} / ${documentsTotal}`;
            if (currentFileEl) currentFileEl.textContent = currentFile;
            if (speedEl) speedEl.textContent = speed ? `Viteză: ${speed}` : 'Viteză: -';
        }

        // Function to hide sync progress modal
        function hideSyncProgress() {
            const modal = document.getElementById('syncProgressModal');
            if (modal) {
                modal.classList.add('hidden');
            }
        }

        // Add test function for debugging PDF upload issues
        function testPDFUpload() {
            console.log('🧪 === TESTING PDF UPLOAD ===');
            console.log('🧪 Current user:', window.currentUser);
            console.log('🧪 Current folder path:', window.currentFolderPath);
            console.log('🧪 Upload target path:', window.uploadTargetPath);
            console.log('🧪 Institution path:', window.currentUser?.institution_name);
            
            // Test file path construction
            const testFilePath = '/Users/PDS/Documents/test.pdf';
            const testTargetPath = 'Scoala Dabuleni/HUIJEN';
            const testFileName = 'test.pdf';
            
            console.log('🧪 Test data:');
            console.log('  - File path:', testFilePath);
            console.log('  - Target path:', testTargetPath);
            console.log('  - File name:', testFileName);
            
            // Simulate the process-file IPC call
            console.log('🧪 Simulating process-file IPC call...');
            ipcRenderer.send('process-file', {
                filePath: testFilePath,
                targetPath: testTargetPath,
                fileName: testFileName,
                fileType: 'application/pdf',
                fileSize: 1024
            });
            
            console.log('🧪 Test completed - check main process logs');
        }
        
        // Add test button to the UI
        function addTestButton() {
            const testBtn = document.createElement('button');
            testBtn.textContent = '🧪 Test PDF Upload';
            testBtn.className = 'bg-red-600 hover:bg-red-700 text-white px-3 py-1 rounded text-sm ml-2';
            testBtn.onclick = testPDFUpload;
            
            // Add to the upload center area
            const uploadCenter = document.querySelector('.upload-center');
            if (uploadCenter) {
                const header = uploadCenter.querySelector('.upload-header');
                if (header) {
                    header.appendChild(testBtn);
                }
            }
        }
        
        // Call this when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(addTestButton, 1000);
        });
        
        // Make functions globally available
        window.showSyncProgress = showSyncProgress;
        window.updateSyncProgress = updateSyncProgress;
        window.hideSyncProgress = hideSyncProgress;
        window.testPDFUpload = testPDFUpload;
        
    </script>
</body>
</html> 